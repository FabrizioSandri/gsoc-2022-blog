{
  
    
        "post0": {
            "title": "DeepState introduction",
            "content": "DeepState Introduction . DeepState is a framework which provides developers the possibility to perform symbolic unit testing on some particular C++ functions by writing test harnesses. For writing a test harness, Deepstate follows a similar approch to the one of Google tests 1. The common problem between most of the symbolic unit testing libraries is that you as developer have to know how to use other binary analysis tools. With Deepstate this problem is solved by provinding a common interface the test harness creation process. . Installation . The installation process is quite simple, you just need to follow the istruction provided in the Readme file in the Deepstate repository on GitHub 2. In my case after the installation of all the necessary dependencies, I downloaded the repository snapshot using the standard git clone approach . git clone https://github.com/trailofbits/deepstate.git . and then started the compilation process with the auxiliary of Make tools . mkdir deepstate/build &amp;&amp; cd deepstate/build cmake ../ make . If the compilation process succeed the next step is the installation of the compiled files in the proper location in the host system: . sudo make install . Test Harness creation . Testing C++ code is not a straightforward task and it need to be accomplished in the correct way, otherwise it will lead to a failure both in the test and also in the source code. A Test Harness is a collection of software that allows to test a particular program by executing under some conditions. . The first step in test harness creation is to include the library and optionally set the namespace, in order to use all the functionalities provided by DeepState : . #include &lt;deepstate/DeepState.hpp&gt; using namespace deepstate; . A Test Harness definition in DeepState starts with the TEST macro. This macro takes two arguments as input: . a unit name | a test name | . The body of the function that starts with TEST will contain the following parts: . symbols definition | pre-conditions | post-conditions | . Let’s dive into this three main parts of a Test Harness creation procedure. . Symbols definition . The first part consists in the definition of the symbols that will be used as input for the function we need to test. The main goal for this task is to have a set of variables that will be filled by the DeepState with some non-deterministic data. . Symbolic execution tools and fuzzers needs to know which variable is symbolic in order to control them. Symbols definitions for basic data types (int, char, ..) are defined by concatenating the data type name with the symbolic_ prefix (symbolic_int, symbolic_char, ..). . DeepState provides us some useful functions to initialize our symbols with random data: . int DeepState_IntInRange(int low, int high) : initializes the symbol with an integer in the range low-high | float DeepState_FloatInRange(float low, float high) : initializes the symbol with a float number in the range low-high | double DeepState_DoubleInRange(double low, double high) : initializes the symbol with a double number in the range low-high | char* DeepState_CStr_C(size_t len, const char* allowed) : initializes a character array (a string) of length len with a set of allowed character taken from the character array `allowed | char* DeepState_CStrUpToLen(size_t maxLen, const char* allowed) : initializes a character array (a string) of length up to len with a set of allowed character taken from the character array allowed | . Pre conditions . Sometimes there is the necessity to constraint a little bit more the symbolic variables defined previously. This means that you have some particular constraint that your symbolic variable need to comply with, before running into the tests. All the tests that do not pass the pre conditions will be considered abandoned. . Pre conditions are defined using the ASSUME macro and also by the following more specialized ones: . ASSUME_EQ : checks for the equality of the 2 parameters (operator ==) | ASSUME_NE : checks if the 2 parameters are not equal (operator !=) | ASSUME_LT : checks if the first parameter is less than the second (operator &lt;) | ASSUME_LE : checks if the first parameter is less or equal to the second (operator &lt;=) | ASSUME_GT : checks if the first parameter is greater than the second (operator &gt;) | ASSUME_GE : checks if the first parameter is greater or equal to the second (operator &gt;=) | . Example . Suppose you have to pass to your test only strings with a minimum length of 5 characters and up to 10 characters (both inclusive). This types of strings can not be created by only using DeepState_CStrUpToLen. We have to constraint the fact that the length of the string should also be greater then 5. This may be accomplished by using a precondition that checks if the created string meets the requirement that its length be larger than or equal to 5. With the preceding list in mind, this can be implemented with the ASSUME_GE macro in the following way: . TEST(UnitName, TestName) { char* str = DeepState_CStrUpToLen(50, &quot;abcdefABCDEF&quot;); ASSUME_GE(strlen(str), 5); ... } . Post conditions . The last part is the check of the execution result of a test. This can be done with post conditions that checks if the results satisfy some constraints. Similar to the pre conditions, the post condition defines a list of macros that help us to perform this checks. This time a post condition is defined using the ASSERT macro and all it’s specialized versions (ASSERT_EQ, ASSERT_NE, ASSERT_FALSE, …). . Example . Assume that we want to test a function that compress a string as input into a fixed length string : an hash function like MD5. A possible post condition will check if the hashed string is of a certain length (in the case of md5, exactly 32 characters). . TEST(UnitName, TestName) { char* str = DeepState_CStrUpToLen(50, &quot;abcdefABCDEF&quot;); // Pre conditions ASSUME_GE(strlen(str), 5); // execution char* hashedString = md5(str); // post conditions ASSERT_EQ(strlen(hashedString), 32); } . Test harness compilation . You can compile the test harness using a standard C++ compiler like g++ by specifying the linker to include the deepstate header with the -ldeepstate parameter . g++ -ldeepstate -o harness harness.cpp . The output of this procedure is a compiled harness file that can be executed. . Fuzz test execution . The compiled test harness can be executed using some analysis tools like manticore, angr or valgrind to discover memory leaks in the code. You can also run it in a standalone mode by executing it directly in the console with the --fuzz option. This last option enables DeepState to perform brute force fuzzing. Another useful option is --timeout that allows to specify a timeout(in seconds) after which the fuzzing procedure will be stopped. In addition with the --input_which_test you can specify the test to execute in the format UnitName_TestName. . ./harness --fuzz --timeout=5 --input_which_test UnitName_TestName . This execution will give us the total number of failed, passed and abandoned tests . Advanced fuzz testing . I’ll go through how to use DeepState in conjunction with more complex tools like Valgrind in the next blog posts. . https://google.github.io/googletest/ &#8617; . | https://github.com/trailofbits/deepstate#buildnrun &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/deepstate/fuzz/c++/2022/05/25/about-deepstate.html",
            "relUrl": "/deepstate/fuzz/c++/2022/05/25/about-deepstate.html",
            "date": " • May 25, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Sample DeepState fuzz test",
            "content": "Sample usage of the Deepstate C++ library . Assume that the NASA FPrime library contains a function that converts a string to a Mixed-Uppercase string. In reality the NASA FPrime contains a lot of functions that deals with strings. What is a Mixed-Uppercase string? With this term I am referring to a string which all characters in odd positions must be capitalized. The following is a very simple function that computes this task: . char* mixedUppercase(char* source){ for( int i=0; i&lt; strlen(source); i+=2 ){ // check if the character at the ith position is lowercase, otherwise skip if (*(source + i) &gt;= 97 &amp;&amp; *(source + i) &lt;= 122){ *(source + i) -= 32; } } return source; } . This function takes a character array as input and performs the odd-uppercase replacement in place. This function returns the pointer to the first character of the original char vector. . Test harness creation . First of all I’ll start writing the TestHarness after I’ve determined what the expectations are for this function. First, I’ll include the DeepState library’s required header files: . #include &lt;deepstate/DeepState.hpp&gt; . Then, using the TEST macro, I’ll begin constructing the test function, taking into account the expected outcome from the mixedUppercase function. The following code sample illustrates one possible implementation: . TEST(MixedUppercase, OnlyGeneratedMixedUppercase) { char* str = DeepState_CStrUpToLen(50, &quot;abcdefABCDEF&quot;); ASSUME_GT(strlen(str), 1); mixedUppercase(str); ASSERT_TRUE(isMixedUppercase(str)) &lt;&lt; str &lt;&lt; &quot; is not a mixed uppercase string&quot;; } . This test function creates a string with a length of up to 50 characters, containing characters from the set &quot;abcdefABCDEF&quot;. After that we make the assumption that the the strings that are relevant for the test are the one of a length greter than 1. Finally we execute our function and we check using the ASSERT_TRUE postcondition that the result is a Mixed-Uppercase string. . Where the isMixedUppercase function returns True if the string passed is a Mixed-Uppercase string, otherwise false. . bool isMixedUppercase(char* str){ bool res = true; for (int i=0; i&lt; strlen(str); i+=2){ res = res &amp;&amp; (*(str + i) &gt;= 65 &amp;&amp; *(str + i) &lt;= 90); } return res; } . Fuzz testing . Now that the Test harness is written, I can move on and perform some fuzz testing over the function. First I will compile the Test harness by specifying the linker to include the deepstate header with the -ldeepstate parameter . g++ -ldeepstate -o harness harness.cpp . Finally I run a non deterministic fuzz testing on the TestHarness by executing the compiled TestHarness with the following parameters . ./harness --fuzz --timeout=1 --input_which_test MixedUppercase_OnlyGeneratedMixedUppercase . Result . After the execution I can check the results. As expected, in my case no error was found. . INFO: Starting fuzzing WARNING: No seed provided; using 1652815282 INFO: Done fuzzing! Ran 18918 tests (18918 tests/second) with 0 failed/17447 passed/1471 abandoned tests .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/deepstate/fuzz/c++/2022/05/17/deepstate-sample.html",
            "relUrl": "/deepstate/fuzz/c++/2022/05/17/deepstate-sample.html",
            "date": " • May 17, 2022"
        }
        
    
  

  
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://fabriziosandri.github.io/gsoc-2022-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}