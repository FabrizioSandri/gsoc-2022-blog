{
  
    
        "post0": {
            "title": "Summary of my GSOC experience",
            "content": "Introduction . The conclusion of this long and magnificent experience of GSOC, which began around five months ago, has arrived, and it is now time to recap the points of this long journey. I knew from the first day that this was going to be a fantastic experience, but I never expected to learn so much this summer! . It all started some months ago when my thesis supervisor advised that I engage in this initiative that Google has been doing for several years. My thesis supervisor put me in touch with a PhD student at the University of Trento who had previously participated in GSOC and is now a mentor. Fascinated by his experience, I set out to work to ensure that my proposal was chosen. After several weeks of effort, I submitted my project idea, and on May 20, I received an email informing me that I had been accepted for GSOC 2022; I was overjoyed! . GSOC work . The first three weeks of work, known as the Community Bonding period, have been a chance for me to study and become familiar with the tools that I would be using for the next ten weeks. This period was really beneficial to me since I was able to immerse myself into the R community while also learning a lot of new topics thanks to my blog posts: writing them helped me keep track of everything I had been studying. . In accordance with the goal of my project I’ve been working on two distinct repositories: . FabrizioSandri/RcppDeepState : the RcppDeepState package implementation, which runs fuzz testing with Valgrind and DeepState; | FabrizioSandri/RcppDeepState-action : Implementation of the GitHub action that allows developers to execute RcppDeepState on GitHub-hosted Rcpp-based packages. The action is also available on the GitHub Marketplace. | . All of my progress on the two aforementioned repositories is documented in the pull requests and issues listed underneath. Furthermore, the week summaries that I posted at the end of each week give a more detailed explanation of the changes that I made week by week; you can find them here. . FabrizioSandri/RcppDeepState-action . Pull requests Issues . #1 First prototype | #2 Exit codes | #3 Input arguments | #4 Composite action | #6 Action&#39;s comments | #7 Action&#39;s comments - 2 | #8 Additional arguments and documentation | #9 Docker hub integration | #10 Report size exceeds the maximum GitHub comment size | #12 Docker Hub tags problem | #15 Report details | #17 Get errors count | #18 Parameters names/values | #20 Dependencies issue | #21 Action logs enhancement | . | #2 Segmentation fault not catched | #4 Fuzzing functions with Rcpp parameters | #7 Valgrind for initial pass | #8 RcppDeepState optimization options | #10 Missing Rcpp Strings support | #13 Wrong inputs column | #18 Valgrind and Clang-14 dwarf support | . | . FabrizioSandri/RcppDeepState . Pull requests Issues . #1 Makefile generation fix and improvements | #3 Override default Makevars | #5 Harness creation improvements | #6 Debug symbols tests | #9 Logging improvements | #11 Rcpp string support | #12 Fuzz only supported functions | #14 qs::c_qsave moved to the runner | #15 Automatically setup CI | #16 Harness creation improvements - 2 | #17 Custom test harness | #19 Harness unit test name | #20 Editable functions | #21 Harness unit test name - 2 | #22 Exit status codes | #23 Harness creation improvements - 3 | #24 Makevars issue | #25 Dependencies problem | #26 IntegerMatrix support | #27 Dependencies issue | . | #5 what to do when auto comments are too large? | #11 Docker Hub integration trigger event | #13 SHA in PR comment? | #14 beta test on other packages? | #16 parameter names / value? | #19 Not finding source files from DESCRIPTION LinkingTo: field? | . | . Future work . There’s still a lot to accomplish with RcppDeepstate, and I’m specifically talking to the fact that a future step would be the package’s release on CRAN. As the goal of my project, I spent a lot of time during the GSOC improving RcppDeepState for a future CRAN publication, but with all of the problems related to Deepstate portability on Windows-based systems, I believe that this is a future step, as demonstrated by the results obtained after uploading the package on Win-builder: most of the errors were caused by the use of a Windows system. . Another step would be to expand RcppDeepState’s datatype coverage by introducing additional datatypes, allowing RcppDeepState to run on a broader range of packages. To do this, I created a wiki article that describes how to Add a new datatype to RcppDeepState. The scope of this page has been successfully shown thanks to Dr.Martin R. Smith’s first external contribution to the RcppDeepState package. More information is available in the dedicated blog post. . Another future improvement would be to provide a new option to RcppDeepState-action that allows users to choose a different fuzzer than the default one provided by Deepstate; Libfuzzer, Manticore and Angr are three alternative fuzzers. . My GSOC experience . My gsoc experience was incredible, something I never imagined, and it was one of the best in my career. This experience taught me a lot about working with others and contributing to open source. At the end of this experience, I can certainly say that I will spend more time to open source than the time I’ve spent so far. As a maintainer, I will continue to contribute to my project. . I am grateful to all of my mentors who took the time to guide me through this journey and share their unique experience and knowledge with me. Special thanks go to: . my evaluating mentor Dr.Toby Dylan Hocking, who has always been available to help me during the Google Summer of Code. I was able to stay on track and keep up the good work thanks to his helpful guidance. | my mentor Randy Lai, who helped me with his great experience with GitHub Actions to improve the RcppDeepState action; | my mentor Anirban Chetia, who gave me good suggestions on the challenges I had in the early stages of utilizing RcppDeepState; | Dr.Martin R. Smith, for his great availability to beta test my GitHub action on his packages and for integrating a new datatype to RcppDeepState; | all of the R community people I’ve interacted with on GitHub, the RcppCore team; | Google/GSOC for organizing this fantastic event year after year. | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/summary/2022/09/08/gsoc-summary.html",
            "relUrl": "/summary/2022/09/08/gsoc-summary.html",
            "date": " • Sep 8, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "▸ Week 13 Summary",
            "content": "Introduction . This post is meant to be a reference for the work I’ve done during the thirteenth week. . Week 13 . This week’s major emphasis was on beta testing and resolving bugs uncovered during beta testing. I was able to automatically beta test certain packages and analyze the results using the scripts that I wrote in two of my earlier blog posts. You can find more details on the results that I obtained in the dedicated blog post. . Starting with RcppDeepState: . RcppDeepState failed with an error saying that the package has missing dependencies when run on packages having certain dependencies under the linkingTo field. As a consequence of a conversation with my mentor, I found a solution for this problem: substitute the R CMD INSTALL system command with the install.packages function used to construct the library’s shared object. This manner, we avoid using system commands, which is usually a bad idea if the goal is to make RcppDeepState multiplatform. In addition, I reviewed the prerequisites for running RcppDeepState: in order to run RcppDeepState, the user must install all missing dependencies pf the tested package, using for example devtools::install(); | As a consequence of beta testing, Dr.Martin R. Smith, creator of multiple R packages available on CRAN, needed support for the IntegerMatrix datatype in one of his packages. After following the wiki page description, he sent a pull request to the RcppDeepState repository, requesting me to add this new datatype. This was a successful outcome that allowed me to confirm that the process for adding a new datatype is well documented. | . Regarding RcppDeepState-action the changes apported this week amount to: . changed the name of the time_limit parameter to max_seconds_per_function; | checked whether single quotes are required for parameters like booleans and integers inside workflow files; | solved the problem that caused the action’s log to include a warning message: rm: missing operand; | solved the issue that caused a duplicate concatenation of the src path in the hyperlinks of the comment; | strengthened the tests on NA values to avoid unexpected errors; | moved the package installation procedure to the action code. This manner, it will only be run once, rather to each time a RcppDeepState makefile is created. devtools::install is used to install the package with its dependencies. | . Reference . Pull requests: . Dependencies problem | IntegerMatrix support | Dependencies issue | Parameters names/values | Dependencies issue | . Issues: . parameter names / value? | beta test on other packages? | Not finding source files from DESCRIPTION LinkingTo: field? | . Blog posts: . Issue with RcppDeepState-action beta test | Beta testing results | . External pull requests: . Analyze the package with RcppDeepState | RcppDeepState-action missing system dependency | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/summary/2022/09/03/week-13.html",
            "relUrl": "/summary/2022/09/03/week-13.html",
            "date": " • Sep 3, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Beta testing results",
            "content": "Introduction . Beta testing is the process of evaluating a software prototype right before its release in order to detect flaws. This procedure can be appropriately conducted by a third party who is using the program for the first time, the beta tester. It’s important to note that the most important part of this phase is observing the user’s interactions with the program without any input from the developers in order to identify the most critical sections that need to be handled. . Thanks to my mentor, I was able to take part in several live beta testing sessions where I was the observer and my mentor was the beta tester. The main goal of this session was to uncover weaknesses and difficulties in the technique for configuring RcppDeepState-action. As an observer, I couldn’t participate; all I could do was take notes on potential difficulties. This session showed me that no matter how much time I spent looking for bugs in the code I wrote, I would never find them in a short period of time; beta testing, on the other hand, allowed me to rapidly detect flaws. . A new strategy . Live sessions are extremely beneficial, but they are not the only strategy to beta test the code. Another possibility for speeding up the process on a large scale is to use automated techniques to test the code and compare the results to others that we already have access to. This is exactly what I talked about in my earlier blog post about beta testing RcppDeepState-action on GitHub-hosted CRAN packages1. . To recap the previous blog posts, I wrote two script: . one that automatically initializes the RcppDeepState-action on a list of preset GitHub repositories that included problems according to Akhila’s article2. This test were ran within the forked version of the repository to ensure that there were no permission issues with the GitHub tokens1; | the other one that automatically replicates the RcppDeepState reports as a comment on the remote repositories3. | . Using this method, I was able to identify a number of new issues with the RcppDeepState library. The most problematic one I discovered was that RcppDeepState would not build the shared object file in some circumstances due to missing dependencies in the tested packages. The incorrect usage of R CMD INSTALL inside the package to build the shared object file without first installing the missing package dependencies caused this issue. This problem was also reported to me by Dr.Martin R. Smith, author of numerous R packages accessible on CRAN, like Quartet and TreeSearch. . Furthermore, while examining the TreeSearch package, Dr. Smith identified another issue: one of its packages was not analyzed because some datatypes fell outside of the list of datatypes supported by RcppDeepState. He asked if this was expected behavior, and I said yes, as well as providing him with a detailed description of the error’s motivation, as well as a link to the RcppDeepState wiki article on how to add support for a new datatype. Dr. Smith then made a pull request4 to the RcppDeepState repository, asking for the IntegerMatrix datatype to be added to RcppDeepState. Because of this, I was able to determine whether or not the method required to add support for a new datatype is properly documented; based on the results, I can claim that Dr.Smith did an excellent job by following all of the wiki steps one by one. . Conclusion . Finally, I can say with certainty that beta testing really helped me in determining what the issues are with RcpDeepStare. Specifically, because to this new technique, I was able to collect feedback from beta testers, like in the case of Dr.Smith. . . Beta test RcppDeepState-action on GitHub hosted CRAN packages &#8617; &#8617;2 . | Rcpp-based packages where RcppDeepState found issues1. &#8617; . | Issue with RcppDeepState-action beta test &#8617; . | IntegerMatrix support &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/github%20action/2022/09/02/beta-test-summary.html",
            "relUrl": "/github%20action/2022/09/02/beta-test-summary.html",
            "date": " • Sep 2, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Issue with RcppDeepState-action beta test",
            "content": "Introduction to the issue . After performing beta tests on the binsegRcpp1 package using RcppDeepState-action I discovered two issues. . The first is that the user need consent from a single maintainer with write access before running a workflow within a remote repository. This has been demonstrated with my mentor through pull request tdhock/binsegRcpp#16. In fact, this is explicitly stated in the GitHub documentation2: . To help prevent this, workflows on pull requests to public repositories from some outside contributors will not run automatically, and might need to be approved first. By default, all first-time contributors require approval to run workflows. . However, this is not the only issue: the person who opens a pull request is not permitted to use the remote repository’s GITHUB_TOKEN to automatically add a comment in the pull request. The token is only valid inside the same repository. This is clearly explained in the GitHub docs3: . When you enable GitHub Actions, GitHub installs a GitHub App on your repository. The GITHUB_TOKEN secret is a GitHub App installation access token. You can use the installation access token to authenticate on behalf of the GitHub App installed on your repository. The token’s permissions are limited to the repository that contains your workflow. . Workaround . The primary purpose is to run RcppDeepState-action on CRAN packages available on GitHub and share the findings with the package authors. To accomplish this task, the following steps can be used as a workaround for the previous issues: . fork the remote repository; | Create a self-pull request(from fork to fork) in the forked repository to examine the package using RcppDeepState-action; | If RcppDeepState finds at least one error, make a pull request on the remote repository(from fork to upstream); | Copy and paste the RcppDeepState report from the forked repository’s pull request into the pull request of the remote repository. | Implementation . According to the script that automatically forks and opens a self pull request written in the previous blog post4, we can write a script that, after the RcppDeepState-action workflow is done, opens a remote pull request on the original repository and copies and pastes the RcppDeepState report within the remote pull request. . The first step is to import the required libraries and get the GitHub personal access token (PAT) stored in an environment variable called GITHUB_PAT in my case. This token will be used to authorize the push of local commits to a repository’s remote branch. To generate this token, you can follow the instructions provided by GitHub5. . library(&quot;gh&quot;) library(&quot;git2r&quot;) library(&quot;data.table&quot;) cred &lt;- cred_token(token = &quot;GITHUB_PAT&quot;) batch_size &lt;- 10 # adjust the batch size organization &lt;- &quot;RcppDeepState&quot; . In this case, we have defined two additional parameters, one of which is the batch_size parameter, which limits the number of packages tested. This option must be equivalent to the batch_size parameter used when executing the script that forks and creates a pull request4, or else some pull request will not be submitted. Furthermore, we define the organization parameter, which searches for forked repositories inside the organization provided in this parameter. This parameter has been added after the problem outlined in the Future work paragraph of the previous blog post. . Given a pkg.repos data table produced by following the steps specified in Dr.Toby Dylan Hocking’s blog post6, the implementation of the automatic process outlined above is described in the next steps. . &gt; pkg.repos Package repo.url 1: humaniformat https://github.com/ironholds/humaniformat 2: jmotif https://github.com/jMotif/jmotif-R 3: olctools https://github.com/Ironholds/olctools 4: RcppDynProg https://github.com/WinVector/RcppDynProg 5: BWStest https://github.com/shabbychef/BWStest 111: tweenr https://github.com/thomasp85/tweenr 112: uwot https://github.com/jlmelville/uwot 113: vapour https://github.com/hypertidy/vapour 114: wk https://github.com/paleolimbot/wk 115: wkutils https://github.com/paleolimbot/wkutils . pull_body_template &lt;- paste(&quot;This PR adds a new Github Action which runs&quot;, &quot;RcppDeepState+valgrind on your package. That means the C++&quot;, &quot;functions of your package will be tested with random&quot;, &quot;inputs, and there will be a comment like this one for each&quot;, &quot;new PR (which reports if valgrind found any issues with&quot;, &quot;random inputs). n n#### RcppDeepState analysis result n&quot;, &quot;This package contains problems, according to&quot;, &quot;RcppDeepState. The report was generated by&quot;, &quot;[RcppDeepState-action](https://github.com/FabrizioSandri/RcppDeepState-action)&quot;, &quot;in this repository&#39;s fork and is accessible &quot;) pkg.repos &lt;- nc::capture_first_df(pkg.repos, repo.url=list( &quot;https://github.com/&quot;, repo_full_name=list( &quot;.*/&quot;, repo_name=&quot;.*&quot;))) for (repo_i in seq(min(batch_size, nrow(pkg.repos)))){ repo &lt;- pkg.repos[repo_i] fork_name &lt;- paste(organization, repo$repo_name, sep=&quot;/&quot;) fork_pull_url &lt;- paste(&quot;https://github.com&quot;, fork_name, &quot;pull&quot;, &quot;1&quot;, sep=&quot;/&quot;) # get the report comment from the forked repository fork_comments_endpoint &lt;- paste0(&quot;GET /repos/&quot;, fork_name, &quot;/issues/1/comments&quot;) rcppdeepstate_pull &lt;- gh(fork_comments_endpoint) if (length(rcppdeepstate_pull) == 0){ warn_msg &lt;- paste(&quot;The report comment has not been generated for&quot;, repo$repo_full_name) message(warn_msg) }else{ rcppdeepstate_comment &lt;- sub(&quot;&lt;!-- RcppDeepState-action comment--&gt;&quot;, &quot;&quot;, rcppdeepstate_pull[[1]]$body) if (grepl(&quot;No error has been reported&quot;, rcppdeepstate_comment, fixed = TRUE)){ warn_msg &lt;- paste(&quot;No error has been reported by RcppDeepState for the&quot;, &quot;package&quot;, repo$repo_full_name) message(warn_msg) }else{ # get the remote repo default branch name upstream_endpoint &lt;- paste0(&quot;GET /repos/&quot;, repo$repo_full_name) upstream_details &lt;- gh(upstream_endpoint) # open a pull request in the original repository pulls_endpoint &lt;- paste0(&quot;POST /repos/&quot;, repo$repo_full_name, &quot;/pulls&quot;) pull_title &lt;- &quot;Analyze the package with RcppDeepState&quot; pull_body &lt;- paste0(pull_body_template,&quot;[here](&quot;, fork_pull_url, &quot;).&quot;) head &lt;- paste(organization, &quot;RcppDeepState&quot;, sep=&quot;:&quot;) pull_response &lt;- gh(pulls_endpoint, title=pull_title, body=pull_body, owner=upstream_details$owner$login, repo=repo$repo_name, base=upstream_details$default_branch, head=head) # issue a comment with the rcppdeepstate report pull_number &lt;- pull_response$number original_comments_endpoint &lt;- paste0(&quot;POST /repos/&quot;, repo$repo_full_name, &quot;/issues/&quot;, pull_number, &quot;/comments&quot;) gh(original_comments_endpoint, owner=upstream_details$owner$login, repo=repo$repo_name, issue_number=pull_number, body=rcppdeepstate_comment) } } } . Test . Before we execute the aforementioned script, we must first run the previous blog post’s code4 to fork the original repository and create the RcppDeepState reports. Remember that the new repositories will be created within the organization specified in the relative variable, as described in the Future work paragraph of the previous blog post4. . Following that, we can ensure that all reports for the repositories being tested have been generated automatically using the following piece of code: . for (repo_i in seq(min(batch_size, nrow(pkg.repos)))){ repo &lt;- pkg.repos[repo_i] fork_name &lt;- paste(organization, repo$repo_name, sep=&quot;/&quot;) fork_comments_endpoint &lt;- paste0(&quot;GET /repos/&quot;, fork_name, &quot;/issues/1/comments&quot;) rcppdeepstate_pull &lt;- gh(fork_comments_endpoint) if (length(rcppdeepstate_pull) &lt; 1){ warn_msg &lt;- paste(&quot;The report for&quot;, repo$repo_full_name, &quot;has not yet been generated.&quot;) message(warn_msg) } } . I tested this script an hour after the automatic fork procedure had finished with a batch size of 10, and it reported that the report for two repositories had not been generated. . The report comment has not been generated for ekstroem/MESS The report comment has not been generated for MikeJaredS/hermiter . By analyzing the logs, I discovered that the reports were not generated because of a missing library that is not installed and is not specified in the package’s prerequisites. According to the error message for the hermiter package, the missing library is RcppParallel: . fatal error: &#39;RcppParallel.h&#39; file not found #include &lt;RcppParallel.h&gt; ^~~~~~~~~~~~~~~~ . Run the remote pull request script . Running the script that submits a pull request remotely will result in the following output: . &gt; source(&quot;remote_pull.R&quot;) No error has been reported by RcppDeepState for the package shabbychef/BWStest The report comment has not been generated for ekstroem/MESS The report comment has not been generated for MikeJaredS/hermiter . Aside from the two previously mentioned repositories, the remote pull request for shabbychef/BWStest will not be submitted because RcppDeepState found no errors. Instead, the report will be submitted in a matter of seconds to the following repositories: . ironholds/humaniformat pull request #8 | jMotif/jmotif-R pull request #35 | Ironholds/olctools pull request #6 | WinVector/RcppDynProg pull request #1 | CollinErickson/CGGP pull request #44 | paulhibbing/PAutilities pull request #8 | ms609/Quartet pull request #63 | . Conclusion and Future work . With this article demonstrated how to add another step to the script that automatically forks and opens a pull request to the remote repositories. In this manner, I used a workaround to address the issues described in the article’s introduction. . Future work will involve increasing the batch_size option to the maximum supported value in order to detect issues in all of the packages identified by Akhila. . . binsegRcpp repository &#8617; . | Approving workflow runs from public forks &#8617; . | Automatic token authentication &#8617; . | Beta test RcppDeepState-action on GitHub hosted CRAN packages &#8617; &#8617;2 &#8617;3 &#8617;4 . | Creating a personal access token &#8617; . | R packages on github &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/github%20action/2022/08/30/rcppdeepstate-beta-test-2.html",
            "relUrl": "/github%20action/2022/08/30/rcppdeepstate-beta-test-2.html",
            "date": " • Aug 30, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "▸ Week 12 Summary",
            "content": "Introduction . This post is meant to be a reference for the work I’ve done during the twelfth week. . Week 12 . My mentor has assigned me an interesting task to begin working on this week: test the current RcppDeepState GitHub Action on GitHub-hosted Rcpp-based packages. This was the main task of this week. With the help of a blog post, I carefully described all of the processes required to beta test the RcppDeepState-action. . Regarding RcppDeepState the changes of this week amount to: . solved the issue that happens when a function takes a std::string as input. This issue was caused by the conversion to string using Rcpp::as&lt;std::string&gt;; | solved the issue caused by RcppDeepState that overwrites the default Makevars file with a flag to include debug symbols in the compiled shared object file (PKG_CXXFLAGS += -g); | written a wiki page to serve as a reference for users who want to extend RcppDeepState’s support for additional datatypes. | . Talking about RcppDeepState-action: . solved the issue with the getErrorsCount function’s unusual error message, &#39;list&#39; object cannot be coerced to type &#39;double&#39;. This resulted from the incorrect use of the list’s sum function and the lapply function. The solution was to use sapply instead of lapply to create a vector; | changed the name of the time_limit parameter to max_seconds_per_function. This clarifies the time limit parameter’s measurement unit; | checked whether single quotes are required for parameters like booleans and integers inside workflow files; | . Reference . Pull requests: . Harness creation improvements - 3 | Makevars issue | Get errors count | Parameters names/values | Rcppdeepstate PR from another repo | . Issues: . beta test on other packages? | parameter names / value? | . Blog posts: . Beta test RcppDeepState-action on GitHub hosted CRAN packages | . Wiki page: . Add a new datatype to RcppDeepState | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/summary/2022/08/27/week-12.html",
            "relUrl": "/summary/2022/08/27/week-12.html",
            "date": " • Aug 27, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "Beta test RcppDeepState-action on GitHub hosted CRAN packages",
            "content": "Introduction . My mentor has assigned me an interesting task to begin working on this week: test the current RcppDeepState GitHub Action on GitHub-hosted Rcpp-based packages. Akhila, the previous RcppDeepState maintainer, had already conducted a similar task, however this was done locally rather than in the package repository. Here’s a list of all the Rcpp-based packages where RcppDeepState found issues1. . Now that RcppDeepState has been integrated with GitHub action, we can test more packages stored on GitHub; all we have to do is fork the original repositories, setup the action within them, and then make a pull request so that the action returns a comment with the analysis result. The main advantages of using RcppDeepState-action inside a repository are that it allows to: . dynamically check for issues inside packages using continuous integration; | reduce the risk of code level bugs that can compromise the entire package; | improve the quality of the final package by making it easier to detect subtler bugs, receiving quick feedbacks and alerts if an error is detected; | . The problem . At the time of writing, CRAN lists 18493 packages, 312 of which have problems, according to Akhila’s report1. Given this list of packages, the question is whether it is feasible to determine if a package is hosted on GitHub. If so, can RcppDeepState be run on this repository? . To begin with, the answer to the first question is yes, and my mentor Dr.Toby Dylan Hocking supplied me with a fantastic method that allows me to find the GitHub repository of a package by evaluating the package’s metadata available on CRAN. This method is based on locating the https://github.com prefix inside the metadata of the package. More information on this technique is available in the corresponding blog post2. . The answer to the second question is affirmative; once we have a link to the repository, we can simply fork it, initialize RcppDeepState-action using the RcppDeepState::ci_setup() method, and submit a pull request; RcppDeepState’s report will be displayed as a comment within the pull request. The problem here is that, given the number of packages listed in the previous step, doing these steps one by one is impractical; consequently, in this post, I propose a method for automating this process. . Solution . The solution makes use of four libraries: . gh3: a minimal client to access the REST API of GitHub; | git2r4: an interface to the libgit2 library, which provides access to Git repositories with some basic commands; | data.table5: a library to aggregate large data and run fast operations; | RcppDeepState6: a package to fuzz test your R library’s C++ code in order to find more subtle bugs like memory leaks or even more general memory errors. | . Steps . The first step is to import the required libraries and get the GitHub personal access token (PAT) stored in an environment variable called GITHUB_PAT in my case. This token will be used to authorize the push of local commits to a repository’s remote branch. To generate this token, you can follow the instructions provided by GitHub7. . library(&quot;gh&quot;) library(&quot;git2r&quot;) library(&quot;RcppDeepState&quot;) library(&quot;data.table&quot;) cred &lt;- cred_token(token = &quot;GITHUB_PAT&quot;) . Given a pkg.repos data table produced by following the steps specified in Dr.Toby Dylan Hocking’s blog post2, the implementation of the automatic fork/pull-request process mentioned above is described in the next steps. . &gt; pkg.repos Package repo.url 1: humaniformat https://github.com/ironholds/humaniformat 2: jmotif https://github.com/jMotif/jmotif-R 3: olctools https://github.com/Ironholds/olctools 4: RcppDynProg https://github.com/WinVector/RcppDynProg 5: BWStest https://github.com/shabbychef/BWStest 111: tweenr https://github.com/thomasp85/tweenr 112: uwot https://github.com/jlmelville/uwot 113: vapour https://github.com/hypertidy/vapour 114: wk https://github.com/paleolimbot/wk 115: wkutils https://github.com/paleolimbot/wkutils . We begin by removing the http://github.com prefix from each repository url, resulting in with a new column containing strings in the format &lt;repository owner&gt;/&lt;repository name&gt;. . pkg.repos[, repo_full_name := sub(&quot;https://github.com/&quot;, &quot;&quot;, repo.url) ] . &gt; pkg.repos Package repo.url repo_full_name 1: humaniformat https://github.com/ironholds/humaniformat ironholds/humaniformat 2: jmotif https://github.com/jMotif/jmotif-R jMotif/jmotif-R 3: olctools https://github.com/Ironholds/olctools Ironholds/olctools 4: RcppDynProg https://github.com/WinVector/RcppDynProg WinVector/RcppDynProg 5: BWStest https://github.com/shabbychef/BWStest shabbychef/BWStest 111: tweenr https://github.com/thomasp85/tweenr thomasp85/tweenr 112: uwot https://github.com/jlmelville/uwot jlmelville/uwot 113: vapour https://github.com/hypertidy/vapour hypertidy/vapour 114: wk https://github.com/paleolimbot/wk paleolimbot/wk 115: wkutils https://github.com/paleolimbot/wkutils paleolimbot/wkutils . Then we can iterate over the repositories listed above, forking and cloning each one. Let us call each repository in the loop repo_full_name. . fork_endpoint &lt;- paste0(&quot;POST /repos/&quot;, repo_full_name, &quot;/forks&quot;) fork_result &lt;- gh(fork_endpoint) repo &lt;- clone(fork_result$clone_url, fork_result$name) config(repo, http.followRedirects=&#39;true&#39;) . After successfully cloning the repository, a new branch for the RcppDeepState analysis can be created. RcppDeepState is the name of this new branch. . test_branch_name &lt;- &quot;RcppDeepState&quot; test_branch &lt;- branch_create(last_commit(repo), test_branch_name) checkout(repo, test_branch_name) . The following step is to determine if the repository includes a legitimate package. This is accomplished by checking the existence of the DESCRIPTION file within the repository’s root: if this file exists, the repository includes a valid package that can be examined using RcppDeepState; otherwise, RcppDeepState cannot analyze the package. . if (!file.exists(file.path(&quot;./&quot;, fork_result$name, &quot;DESCRIPTION&quot;))){ stop(&quot;The repository doesn&#39;t contain a valid package&quot;) } . We can now use the existing ci_setup function to initialize the workflow file within the repository. This function accepts as input the location of the repository on the filesystem and a list of parameters corresponding to the action’s inputs. In this scenario, we’ve specified fail_ci_if_error=TRUE to cause the CI process to fail if an error is discovered, and comment=TRUE to print the report comment inside the pull request that will be produced in the following phase. . RcppDeepState::ci_setup(fork_result$name, fail_ci_if_error=TRUE, comment=TRUE) . The last step is to push the new changes to the forked repository and submit a pull request. . # commit and push the workflow file add(repo, file.path(&quot;./&quot;, fork_result$name, &quot;.github&quot;, &quot;workflows&quot;, &quot;*&quot;)) commit(repo, message=&quot;RcppDeepState CI Setup&quot;) push(repo, &quot;origin&quot;, paste(&quot;refs&quot;, &quot;heads&quot;, test_branch_name, sep=&quot;/&quot;), credentials=cred) # open the pull request pulls_endpoint &lt;- paste0(&quot;POST /repos/&quot;, fork_result$full_name, &quot;/pulls&quot;) pull_title &lt;- &quot;Analyze the package with RcppDeepState&quot; pull_body &lt;- paste(&quot;### RcppDeepState Analysis nThis pull request aims to find&quot;, &quot;bugs in this R package using RcppDeepState-action&quot;) gh(pulls_endpoint, title=pull_title, owner=fork_result$owner$login, repo=fork_result$name, body=pull_body, base=fork_result$default_branch, head=test_branch_name) . Final script . We get the following script by combining all of the previous steps with the solution supplied by my mentor. As you can see, a batch_size option has been introduced to allow you to choose the number of repositories to test. This option was added to prevent the creation of 115 repositories within your GitHub account. . library(&quot;gh&quot;) library(&quot;git2r&quot;) library(&quot;RcppDeepState&quot;) library(&quot;data.table&quot;) cred &lt;- cred_token(token = &quot;GITHUB_PAT&quot;) batch_size &lt;- 2 # adjust the batch size if(!file.exists(&quot;problems.html&quot;)){ download.file( &quot;https://akhikolla.github.io./packages-folders/&quot;, &quot;problems.html&quot;) } prob.dt &lt;- nc::capture_all_str( &quot;problems.html&quot;, &#39;&lt;li&gt;&lt;a href=&quot;&#39;, Package=&quot;.*?&quot;, &#39;[.]html&quot;&gt;&#39;) if(!file.exists(&quot;packages.rds&quot;)){ download.file( &quot;https://cloud.r-project.org/web/packages/packages.rds&quot;, &quot;packages.rds&quot;) } meta.mat &lt;- readRDS(&quot;packages.rds&quot;) meta.dt &lt;- data.table(meta.mat) meta.prob &lt;- meta.dt[prob.dt, on=&quot;Package&quot;] pkg.repos &lt;- meta.prob[, nc::capture_all_str( c(&quot;&quot;,URL), # to avoid attempting to download URL. repo.url=&quot;https://github.com/.*?/[^#/ ,]+&quot;), by=Package] pkg.repos[, repo_full_name := sub(&quot;https://github.com/&quot;, &quot;&quot;, repo.url) ] for (repo_full_name in head(pkg.repos$repo_full_name, batch_size)){ fork_endpoint &lt;- paste0(&quot;POST /repos/&quot;, repo_full_name, &quot;/forks&quot;) fork_result &lt;- gh(fork_endpoint) repo &lt;- clone(fork_result$clone_url, fork_result$name) config(repo, http.followRedirects=&#39;true&#39;) test_branch_name &lt;- &quot;RcppDeepState&quot; test_branch &lt;- branch_create(last_commit(repo), test_branch_name) checkout(repo, test_branch_name) ### check if the repository&#39;s root contains a valid package if (!file.exists(file.path(&quot;./&quot;, fork_result$name, &quot;DESCRIPTION&quot;))){ stop(&quot;The repository doesn&#39;t contain a valid package&quot;) } RcppDeepState::ci_setup(fork_result$name, fail_ci_if_error=TRUE, comment=TRUE) # commit and push the workflow file add(repo, file.path(&quot;./&quot;, fork_result$name, &quot;.github&quot;, &quot;workflows&quot;, &quot;*&quot;)) commit(repo, message=&quot;RcppDeepState CI Setup&quot;) push(repo, &quot;origin&quot;, paste(&quot;refs&quot;, &quot;heads&quot;, test_branch_name, sep=&quot;/&quot;), credentials=cred) # submit a pull request pulls_endpoint &lt;- paste0(&quot;POST /repos/&quot;, fork_result$full_name, &quot;/pulls&quot;) pull_title &lt;- &quot;Analyze the package with RcppDeepState&quot; pull_body &lt;- paste(&quot;### RcppDeepState Analysis nThis pull request aims to&quot;, &quot;find bugs in this R package using RcppDeepState-action&quot;) gh(pulls_endpoint, title=pull_title, owner=fork_result$owner$login, repo=fork_result$name, body=pull_body, base=fork_result$default_branch, head=test_branch_name) } . Test . Before running the preceding script, I assumed that running it with a batch_size of 115(nrow(pkg.repos$repo_full_name)) would result in a massive generation of repositories within my GitHub account. As a preliminary solution, I set the batch_size argument to 2, which means that just two packages will be examined. I explain a possible approach to avoid this massive production of repositories under my GitHub user profile in the Future work paragraph. . The following repositories will be tested with a batch_size of 2: . ironholds/humaniformat | jMotif/jmotif-R | . Following the execution of the above script, two repositories will be automatically generated by forking the originals. If you go inside the repositories’ pull requests, you’ll see that a new pull request titled Analyze the package with RcppDeepState has been automatically submitted. After a few minutes, when the CI checks are completed, you will see a comment inside the pull request with the analysis result. . Results . The findings of the analysis are publicly available on Github, and they highlight some issues within the evaluated packages. If we compare the results to those discovered by Akhila1, we can see that there are some similarities. . Here are the links to the results: . humaniformat results | jmotif-R results | . Future work . Creating 115 repositories, as previously said, will result in a huge generation of repositories within my GitHub account. This is not a problem solely because of the number of repositories, but if I need to remove all of them, I will undoubtedly have to write a script to do so; this can be a dangerous task if done in my current working environment (my user profile) because I may accidentally specify the incorrect condition and end up deleting the wrong repositories. . One possible solution is to create a Github Organization and instruct the above script to fork the repositories to a specific organization rather than to my GitHub account. This can be accomplished by passing an extra argument to the GitHub REST API: the organization parameter; this parameter must be set to the organization’s name. The rest of the code will be left unchanged. . fork_endpoint &lt;- paste0(&quot;POST /repos/&quot;, repo_full_name, &quot;/forks&quot;) fork_result &lt;- gh(fork_endpoint, organization=&quot;&lt;org name&gt;&quot;) . . Rcpp Packages with Issue Detected using RcppDeepState &#8617; &#8617;2 &#8617;3 . | R packages on github &#8617; &#8617;2 . | CRAN package: gh &#8617; . | CRAN package: packages &#8617; . | CRAN package: data.table &#8617; . | RcppDeeepState &#8617; . | Creating a personal access token &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/github%20action/2022/08/23/rcppdeepstate-beta-test.html",
            "relUrl": "/github%20action/2022/08/23/rcppdeepstate-beta-test.html",
            "date": " • Aug 23, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "▸ Week 11 Summary",
            "content": "Introduction . This post is meant to be a reference for the work I’ve done during the eleventh week. . Week 11 . This week I have been working on both RcppDeepState and it’s GitHub Action. . Starting with RcppDeepState: . implemented new checks for non-zero test harness exit status codes. If an error occurs before deepstate can execute, it will be reported in this way. | fixed the problem that occurs when the folder containing the package being analyzed is not called the same as the package’s name; in this case, the harness will not be evaluated. This is due to the fact that RcppDeepState utilizes the package name as the unit test name, and if a different name is given, Deepstate is unable to identify the test to execute. | . Regarding RcppDeepState-action: . inserted a link referencing the commit SHA that generated the report; | updated the hyperlinks in the file line and address trace columns to the commit SHA rather than the pull request: the pull request code can change over time, so it is preferable to refer to the commit SHA rather than the pull request inside hyperlinks; | added the inputs generator seed in the Report details paragraph of the comment. . | added a third column to the summary table that indicates the number of inputs which caused at least one valgrind message/issue for each function; | changed all of the column names to eliminate the underscore character between words; | I solved the problem with the report that exceeded the maximum allowable comment size that I started last week. This week, I added a step to the Action that uploads an artifact file that contains the whole report file if it has been truncated. | . New look of the Action’s comment . This is the new look of the GitHub comment after the updates of this week. . RcppDeepState Report . function name message file line address trace R code . cum_median_interface | 40 bytes in 1 blocks are definitely lost in loss record 14 of 1,294 | interface.cpp:12 | No Address Trace found | Test code testlist &lt;- list(data_vec = c(4.95282670985293e+269, 9.19220261345616e+228, 9.76446051871464e-227, 3.44002757211463e+142, 3.44564622360808e+125, Inf, -6.84590386509538e-154, 3.40246022599512e+269, -1.28923819757614e-165, 2.81518964059233e+167, -1.25531632864596e-287, -2.67427599032549e-248, 3.34588187587734e-119, -1.23551154415627e-21, -1.02610805187601e-109, 4.16940122332875e+269, -1.78387023887419e+248, -1.05722072744111e+98, -4.76115744068632e+183, -3.88035302297988e+101, -1.56937482455912e-56, NA, -4.75822295269467e+95, 1.98207210521439e-28, -1.15749005895586e-67, 1.50064938648988e-160, Inf, 1.13915958031741e+26, Inf, Inf, -5.34218289504947e-223, -4.2465118855095e-179, 5.50632255056954e-235, 1.39476247744266e+75, 1.69641978386394e-232, -1.77675561435822e-297, 4.25467706108586e-23, 4.89194157273472e+80, -2.27196098452465e-154, 3.08839698258598e+192, 2.35589726999274e-123, -2.63763169515399e+87, -3.19378705311954e+155, -3.74038104538462e-105, -3.16795961327089e+80, 9.14978341696139e+137, -1.50288014544269e-23, 1.43738183421206e-204, -2.35599803385513e-61, -2.99448212415941e+198, -4.0142655383189e+295, 1.61771792417167e+263, 0), weight_vec = c(2.59911756272486e+111, 1.23635737106356e-189, 1.53741044740229e-52, -4.41781541766863e+239, -6.40134612106056e-244, 1.22932559861284e-178, 9.45677812109935e+246, -6.03796060663925e+205, -1.90357180711086e-121, 6.15125704486057e+284, -2.75478977649574e+137, 6.11004203699546e+278, 3.40593845702388e+296, -3.91628109029268e-125, -1.85820166555954e-202, 3.3111091636182e-114, -4.91423732728992e-256, -3.13719918528368e+206, -2.76369409104372e-199, -1.24023111984261e-126, -2.4680069962022e+156, -3.00037236174766e-86, 2.65598591262111e-41, -6.74802436337638e+177, 1.09260531554511e+90, -1.48021774692267e+88, 20068460903947, -9.56718241162573e-150))result &lt;- do.call(binsegRcpp:::cum_median_interface, testlist) . | . Analyzed functions summary . function name tested inputs inputs with issues . binseg_interface | 10 | 0 | . cum_median_interface | 10 | 4 | . depth_first_interface | 10 | 0 | . Report details . Report generated by: 32d0969 | Inputs generator seed: 5 | . Reference . Pull requests: . Editable functions | Harness unit test name - 2 | Exit status codes | Report size exceeds the maximum GitHub comment size | Report details | (binsegRcpp) Check rcppdeepstate | . Issues: . what to do when auto comments are too large? | SHA in PR comment? | . Blog posts: . Provide a custom test harness to RcppDeepState GitHub Action | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/summary/2022/08/20/week-11.html",
            "relUrl": "/summary/2022/08/20/week-11.html",
            "date": " • Aug 20, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "▸ Week 10 Summary",
            "content": "Introduction . This post is meant to be a reference for the work I’ve done during the tenth week. . Week 10 . I have spent most of this week’s time improving the RcppDeepState Action and fixing the existing editable-functions of RcppDeepState. . Regarding RcppDeepState-action: . began addressing the issue caused by GitHub’s comment size limit. I fixed that by truncating the error table provided in the Action’s comment. In the coming week, I intend to add another step to the Action that uploads an artifact file containing the entire report file if it is truncated; | built a new tagging mechanism for the Docker Hub integration. When the docker image is updated on a branch other than main, the action will upload the image to Docker Hub with the tag devel. When the main branch, on the other hand, is updated, the action will push the image with the latest tag. The goal of this new functionality is to keep the GitHub branching method intact. | . In terms of RcppDeepState: . resolved the issue where the unit test name was generated according to the directory containing the test. Instead the test should be named as the analyzed package name, otherwise providing a custom test to the GitHub Action will fail, in search of a test named workspace_function. This happens because the package is located inside /github/workspace/; | improved the existing editable-functions functionalities. Before to this change generation and checks harnesses were wrongly generated. | Removed the user prompt inside deepstate_compile_generate_fun and deepstate_compile_checks_fun. Before to this change, these function waited for user input in the case of a non-defined range or missing assert conditions, respectively, and asked the user whether to continue or not with the creation. | . In terms of RcppDeepState: . fixed the problem where the unit test name was generated according to the directory in which the test was located. Instead, the test should be named with the package name followed by the function being analyzed; otherwise, giving a custom test to the GitHub Action will fail since RcppDeepState is looking for a test named workspace_function. This is due to the package’s location underneath /github/workspace/. The package name now is retrieved from the DESCRIPTION file. | enhanced the existing editable-functions functionalities. Prior to this update, generation and check harnesses were generated incorrectly. | Removed the user prompt from the deepstate_compile_generate_fun and deepstate_compile_checks_fun functions. Prior to this update, these functions waited for user input in the case of a non-defined range or missing assert conditions, and asked the user whether or not to continue with the compilation of the test harness. | . Reference . Pull requests: . Harness unit test name | Editable functions | Report size exceeds the maximum GitHub comment size | Docker Hub tags problem | (binsegRcpp) Check rcppdeepstate | . Issues: . what to do when auto comments are too large? | Docker Hub integration trigger event | . Blog posts: . Provide a custom test harness to RcppDeepState GitHub Action | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/summary/2022/08/13/week-10.html",
            "relUrl": "/summary/2022/08/13/week-10.html",
            "date": " • Aug 13, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "Provide a custom test harness to RcppDeepState GitHub Action",
            "content": "Introduction . Sometimes it can happen that a function in your package cannot be analyzed because of some datatypes falling outside of the set of supported one. In this scenario, RcppDeepState cannot create the test harness automatically, thus the user must supply it manually. . This blog post is meant to be a guide for the users who wants to provide a custom test harness to the RcppDeepState GitHub Action. . Custom test harness . Creating a custom test harness is a difficult operation that must be completed appropriately by adhering to the general test harness structure outlined in the dedicated blog post1. If the test harness is not properly designed, RcppDeepState will not be able to locate and perform the tests. . Before continuing to read this post, you should first read about the test harness structure that RcppDeepState accepts. The following snippet of code contains the harness file’s structure that the user must follow to correctly operate with RcppDeepState. All of this has already been mentioned in the the dedicated blog post1. . #include &lt;fstream&gt; #include &lt;RInside.h&gt; #include &lt;iostream&gt; #include &lt;RcppDeepState.h&gt; #include &lt;qs.h&gt; #include &lt;DeepState.hpp&gt; RInside Rinstance; /** FUNCTION SIGNATURE * signature of the function being analyzed must be added here */ /** INPUTS * here you can define all the inputs for your function, and initialize them * with a random value generator. Define your inputs inside the `#define INPUTS` * macro. * * Example: initialize a random integer parameter &#39;arg1&#39;: * #define INPUTS * int arg1 = DeepState_Int(); */ TEST(&lt;package_name&gt;, generator){ INPUTS } TEST(&lt;package_name&gt;, runner){ INPUTS /** INPUTS DUMP * for each input defined above you have to save it in the &#39;inputs&#39; directory * created before using the function qs::c_qsave(param, &quot;./inputs/arg_name.qs&quot;, * &quot;high&quot;, &quot;zstd&quot;, 1, 15, true, 1). Remember to replace &#39;arg_name&#39; inside * &quot;./inputs/arg_name.qs&quot; with the name of the associated input argument. * * Example: save the &#39;arg1&#39; input defined before: * qs::c_qsave(arg1, &quot;./inputs/arg1.qs&quot;, &quot;high&quot;, &quot;zstd&quot;, 1, 15, true, 1) */ try{ /** FUNCTION INVOCATION * here you have to add the invocation of the function being analyzed with * all its parameters defined in the section PARAMETERS. */ }catch(Rcpp::exception&amp; e){ std::cout&lt;&lt;&quot;Exception Handled&quot;&lt;&lt;std::endl; } } . Provide the test harness to the Action . Once you have created a custom test harness for your function you can provide it to the RcppDeepState GitHub Action by simply creating a subdirectory inside your package’s /inst/testfiles, named as the function that is being analyzed. This folder will contain the harness file that should be named as the function being analyzed plus the _DeepState_TestHarness.cpp suffix. RcppDeepState will look for existing test harness files and use them instead of generating new ones before performing the analysis step. . While doing so, keep in mind the naming standards allowed by RcppDeepState; otherwise, unexpected problems may occur. . Example . Assume that a package stored in the root of a repository has a function named unsupported_datatype that needs to be analyzed with RcppDeepState. Suppose this function has a parameter whose type falls out of the supported datatypes: the Rcpp::LogicalVector datatype. . #include &lt;Rcpp.h&gt; using namespace std; // [[Rcpp::export]] int unsupported_datatype(Rcpp::LogicalVector param){ return param.size(); } . Because the test harness cannot be built automatically, this function cannot be analyzed using RcppDeepState. As mentioned above, one solution to this problem is to manually generate the test harness. . To accomplish this, the user can create a custom test harness and save it in the /inst/testfiles/unsupported_datatype/unsupported_datatype_DeepState_TestHarness.cpp location (relative to the repository’s root). . Conclusion . We saw in this post how to pass a manually created test harness to RcppDeepState-action. This RcppDeepState feature allows developers to analyze functions with unsupported datatypes as arguments. . . Write a custom test harness for functions with unsupported datatypes &#8617; &#8617;2 . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/rcppdeepstate/github%20action/2022/08/11/action-custom-harness.html",
            "relUrl": "/rcppdeepstate/github%20action/2022/08/11/action-custom-harness.html",
            "date": " • Aug 11, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "▸ Week 9 Summary",
            "content": "Introduction . This post is meant to be a reference for the work I’ve done during the ninth week. . Week 9 . This week has been fairly intense; I had a lot of work to do and was able to do what I had planned. . The following are the new RcppDeepState-action features: . Added support for the verbose option to control RcppDeepState’s output verbosity. This parameter was added to RcppDeepState in the previous weeks, and I finally included it to the action; | linked the current GitHub Action with Docker Hub. As a result of this update, the overall time required to run the action has been decreased from an average of 20-30 minutes to less than 10 minutes; | made better use of the find command. It found that using the find command within the action without providing the maximum search depth resulted in a slight latency overhead. I fixed this by specifying the depth and making some changes to this command usage. | . In terms of RcppDeepState: . resolved the issue where wrong inputs were included in the result table. I solved this by moving the “Inputs Dump” code to the runner test; | implemented ci_setup function. Developers can use this function to automatically initialize a workflow file within their repositories for the RcppDeepState analysis; | improved and revised the harness creation process, making some additional changes in response to the usability test performed by my mentors; | added the functionality that allows developers to provide a custom test harness if RcppDeepState cannot generate it automatically for a function (function’s parameters are not within the permitted ones); | resolved the dwarf support issue that occurs when Valgrind is used with Clang version 14. | . Reference . Pull requests: . Additional arguments and documentation | Docker hub integration | qs::c_qsave moved to the runner | Automatically setup CI | Harness creation improvements - 2 | Custom test harness | . Issues: . Wrong inputs column | Valgrind and Clang-14 dwarf support | Manual test harness creation for binseg_interface | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/summary/2022/08/06/week-9.html",
            "relUrl": "/summary/2022/08/06/week-9.html",
            "date": " • Aug 6, 2022"
        }
        
    
  
    
        ,"post10": {
            "title": "▸ Week 8 Summary",
            "content": "Introduction . This post is meant to be a reference for the work I’ve done during the eighth week. . Week 8 . I had planned to begin improving the GitHub action’s execution time this week, however after meeting with my mentor I opted to postpone this task so that I could focus on other high priority tasks. . I have spent most of this week’s time improving the Action’s commenting system. In detail I have: . added a new column R_code containing the executable code that can be directly copied and pasted by the user that wants to test a particular function given the inputs; | added a summary table when RcppDeepState doesn’t find any error; | added a thard option for the action’s comment parameter, the failure value. This parameters is used to specify to the action that a comment should be added to the pull request only when RcppDeepState finds at least one error; | changed the action such that it adds the comment once in a pull request and updates it in subsequent runs; | minor changes: removed the inputs column since the inputs are under the R_code column; fixed the broken hyperlinks; modified the conditions that are applied when the step that adds a comment runs, solving the problem caused by the parameter fail ci if error that prevented the execution of the subsequent steps. | . Reference . Pull requests: . Composite action | Action’s comments | Action’s comments - 2 | Check rcppdeepstate | . Blog posts: . GitHub action’s execution time | Custom test harness for function with unsupported datatypes | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/summary/2022/07/30/week-8.html",
            "relUrl": "/summary/2022/07/30/week-8.html",
            "date": " • Jul 30, 2022"
        }
        
    
  
    
        ,"post11": {
            "title": "Write a custom test harness for functions with unsupported datatypes",
            "content": "Introduction . The list of supported datatypes maintained by RcppDeepState is used to automatically create test harnesses for functions whose supported datatypes fall within this list. This list was created using a frequency table of the top 100 Rcpp types found in CRAN packages1. The complete list of supported datatypes is provided below: . int | double | string | Rcpp::NumericVector | Rcpp::IntegerVector | Rcpp::NumericMatrix | Rcpp::CharacterVector | arma::mat | . It is possible for a function you want to analyze to have a parameter that is not on this list, in which case RcppDeepState will notify you that the function cannot be examined due to an unsupported parameter. . We can&#39;t test the function - unsupported_datatype - due to the following datatypes falling out of the allowed ones: LogicalVector Failed to create testharness for 1 functions in the package - unsupported_datatype . This just indicates that the automatic procedure to create a test harness cannot be used, not that your function cannot be analyzed at all. The test harness must therefore be manually created together with its directory structure, and it must then be examined. I’ll explain this procedure in this blog article. . The procedure . RcppDeepState involves two steps: . generator: automatically generates the harness and all the inputs | runner: analyze the package running each function given the inputs of the generator step | . The generator step cannot be used for a function whose inputs are not supported, so we must manually run the steps to construct the directory structure for this function. This can be done using the existing RcppDeepState functions. . Given the path of the package being analyzed package_location and the name of the function which datatypes fall out of the supported ones function_name, the deepstate_create_makefile function can be used to generate the directory structure for the custom test harness: . deepstate_create_makefile(package_location, function_name) . If everything goes smoothly, you can begin creating the custom test harness for your function. The test harness file must be named function_name_DeepState_TestHarness.cpp, where function_nameis the name of the function you want to analyze. You can use the following template as a reference. . #include &lt;fstream&gt; #include &lt;RInside.h&gt; #include &lt;iostream&gt; #include &lt;RcppDeepState.h&gt; #include &lt;qs.h&gt; #include &lt;DeepState.hpp&gt; RInside Rinstance; /** FUNCTION SIGNATURE * signature of the function being analyzed must be added here */ /** INPUTS * here you can define all the inputs for your function, and initialize them * with a random value generator. Define your inputs inside the `#define INPUTS` * macro. * * Example: initialize a random integer parameter &#39;arg1&#39;: * #define INPUTS * int arg1 = DeepState_Int(); */ TEST(&lt;package_name&gt;, generator){ INPUTS } TEST(&lt;package_name&gt;, runner){ INPUTS /** INPUTS DUMP * for each input defined above you have to save it in the &#39;inputs&#39; directory * created before using the function qs::c_qsave(param, &quot;./inputs/arg_name.qs&quot;, * &quot;high&quot;, &quot;zstd&quot;, 1, 15, true, 1). Remember to replace &#39;arg_name&#39; inside * &quot;./inputs/arg_name.qs&quot; with the name of the associated input argument. * * Example: save the &#39;arg1&#39; input defined before: * qs::c_qsave(arg1, &quot;./inputs/arg1.qs&quot;, &quot;high&quot;, &quot;zstd&quot;, 1, 15, true, 1) */ try{ /** FUNCTION INVOCATION * here you have to add the invocation of the function being analyzed with * all its parameters defined in the section PARAMETERS. */ }catch(Rcpp::exception&amp; e){ std::cout&lt;&lt;&quot;Exception Handled&quot;&lt;&lt;std::endl; } } . Remember to replace &lt;package_name&gt; in the TEST(&lt;package_name&gt;, generator) definition with your package name (without angular brackets). . Once the harness has been created you can generate the inputs and analyze the function containing unsupported datatypes as arguments. . deepstate_fuzz_fun(package_location, function_name) result &lt;- deepstate_harness_analyze_pkg(package_location) . Example . I want to provide an example of the unsupported_datatype function that can be found in the testSAN package2. This function uses a LogicalVector as its single parameter, thus RcppDeepState will skip this function from the analysis. . To solve this I followed all the steps mentioned above. First of all I ran the deepstate_create_makefile function, remembering that I had to define the missing variables(package_location and function_name): . package_location &lt;- &quot;/home/fabri/test/testHarness/RcppDeepState/inst/testpkgs/testSAN&quot; function_name &lt;- &quot;unsupported_datatype&quot; deepstate_create_makefile(package_location, function_name) . At the end of this, a directory containing the following content has been created: . unsupported_datatype ├── inputs ├── Makefile └── unsupported_datatype_output . Then I moved on and created the test harness file inside the unsupported_datatype directory and I renamed this file as unsupported_datatype_DeepState_TestHarness.cpp. I followed the template provided above. This is the result: . #include &lt;fstream&gt; #include &lt;RInside.h&gt; #include &lt;iostream&gt; #include &lt;RcppDeepState.h&gt; #include &lt;qs.h&gt; #include &lt;DeepState.hpp&gt; RInside Rinstance; /** FUNCTION SIGNATURE */ int unsupported_datatype(Rcpp::LogicalVector param); /** INPUTS */ #define INPUTS LogicalVector param = RcppDeepState_LogicalVector(); Rcpp::LogicalVector RcppDeepState_LogicalVector(){ int rand_size = DeepState_IntInRange(1,20); Rcpp::LogicalVector rand_vec(rand_size); for(int i = 0 ; i &lt; rand_size;i++){ rand_vec[i] = DeepState_IntInRange(0,1); } return rand_vec; } TEST(testSAN, generator){ INPUTS } TEST(testSAN, runner){ INPUTS /** INPUTS DUMP */ qs::c_qsave(param, &quot;./inputs/param.qs&quot;, &quot;high&quot;, &quot;zstd&quot;, 1, 15, true, 1); try{ /** FUNCTION INVOCATION */ unsupported_datatype(param); }catch(Rcpp::exception&amp; e){ std::cout&lt;&lt;&quot;Exception Handled&quot;&lt;&lt;std::endl; } } . You can notice that I have created an auxiliary function RcppDeepState_LogicalVector used to generate a random LogicalVector of size ranging from 1 to 20 elements. . Finally I run the last two steps: . deepstate_fuzz_fun(package_location, function_name) result &lt;- deepstate_harness_analyze_pkg(package_location) . If you print the result table you will find that unsupported_datatype has finally been tested with RcppDeepState. . . Top 100 Rcpp types found in CRAN packages &#8617; . | unsupported_datatype function &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/rcppdeepstate/2022/07/29/custom-test-harness.html",
            "relUrl": "/rcppdeepstate/2022/07/29/custom-test-harness.html",
            "date": " • Jul 29, 2022"
        }
        
    
  
    
        ,"post12": {
            "title": "GitHub action's execution time",
            "content": "Introduction . In the previous week I successfully integrated the original Docker action with a composite one. The main result of this update is a more flexible action that makes possible to publish the analysis results on Github; this is possible by publishing an artifact file containing the inputs and adding comments to pull requests. In the past working week (Week 7) I discussed with my mentor Randy about this change and he suggested me to prebuild the entire action and upload it to Docker Hub, which is a service provided by Docker for sharing container images1. In this blog post I describe the process that will be followed this week, in order to prebuild the Docker image and publish it to Docker Hub. . Considerations . The actual execution time of the Action is about 15-30 minutes. A huge amount of this time is spent installing all the missing dependencies, which includes the R package, devtools, and so on. Installing each of these every time the action is triggered is useless. A better approach instead would be to prebuild the docker container and save the image so that it can be reused each time the action will be run. This can be accomplished by publishing the image on Docker Hub. What I expect from this improvement is a reduction of the amount of time spent installing the dependencies. . One last thing to think about is moving the devtools installation command from the entrypoint.sh file to the Dockerfile so that it will be installed when the container is built. . Switch to a prebuilt docker image . The main idea is to replace the actual Action’s Dockerfile with a simple composite step that runs the image from Docker Hub. . In the actual implementation, every time the Action is triggered, a container is built in accordance with the Dockerfile, downloading each dependency one at a time, as you can see in the Dockerfile of the following sample. . FROM ubuntu:latest # setup zoneinfo RUN ln -snf /usr/share/zoneinfo/$INPUT_ZONEINFO /etc/localtime &amp;&amp; echo $INPUT_ZONEINFO &gt; /etc/timezone ### Dependencies installation RUN apt update RUN apt install -y build-essential gcc-multilib g++-multilib cmake python3-setuptools python3-dev libffi-dev clang valgrind libcurl4-gnutls-dev libxml2-dev libssl-dev wget libfontconfig1-dev libharfbuzz-dev libfribidi-dev libfreetype6-dev libpng-dev libtiff5-dev libjpeg-dev r-base # Copy the files to the root filesystem of the container COPY src/entrypoint.sh /entrypoint.sh COPY src/analyze_package.R /analyze_package.R RUN chmod +x /entrypoint.sh # Executes `entrypoint.sh` when the Docker container starts up ENTRYPOINT [&quot;/entrypoint.sh&quot;] . The new composite step will make use of the prebuilt image made available on Docker Hub. The dependencies are all installed in this image, so setting them up won’t take any time; the only overhead will be caused by downloading the prebuilt action. This is the action.yml before the change. . ... runs: using: &quot;composite&quot; steps: - uses: actions/checkout@v2 with: repository: FabrizioSandri/RcppDeepState-action path: RcppDeepState-action - name: Analyze the package with RcppDeepState uses: ./RcppDeepState-action/docker with: fail_ci_if_error: $ location: $ seed: $ time_limit: $ max_inputs: $ ... . After the change, it will look like this: . ... runs: using: &quot;composite&quot; steps: - name: Analyze the package with RcppDeepState uses: docker://fabriziosandri/rcppdeepstate:latest with: fail_ci_if_error: $ location: $ seed: $ time_limit: $ max_inputs: $ ... . As you can see the checkout step has been removed, in fact there’s no need to download the Dockerfile and the related files(/docker folder). This solves the problem of specifying the branch name in the checkout step mentioned by Randy in the pull request #42. However this introduces a new problem: I have to decide which event should trigger the update of the image on Docker Hub. A possible solution for this problem is to update the image every time a new commit on the master branch occurs. The problem with this solution is that, if I make a pull request and want to test some new updates made on the docker image, I have to push the result on the master branch to trigger the update on Docker Hub. . Continuous deploy of the Docker image . Each change to the Docker architecture must be reflected to the image published on Docker Hub. In order to make this process automatic and avoid to manually push the docker image to Docker Hub, as suggested by Randy, there is an existing GitHub Action that automatically builds and publishes Docker images to Docker Hub3. This action can be integrated in the RcppDeepState-action repository inside a workflow’s job that is triggered every time a commit on the master branch occurs. . jobs: docker: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 - name: Set up Docker Buildx uses: docker/setup-buildx-action@v2 - name: Login to DockerHub uses: docker/login-action@v2 with: username: $ password: $ - name: Build and push uses: docker/build-push-action@v3 with: context: ./docker push: true tags: fabriziosandri/rcppdeepstate:latest . A token must be generated in order to publish the image to Docker Hub and authenticate the user before pushing the image on it. This token can be simply generated by going in Profile Settings &gt; Security &gt; Access Tokens &gt; New Access Token. A pop up will appear, asking for the permissions that will be assigned to this token; the value “Read, Write, Delete” is sufficient. . In order to prevent information theft, the token and the username should be kept as a repository secret. In the example above, the variables for the username and token are referred to as DOCKERHUB_USERNAME and DOCKERHUB_TOKEN respectively. These parameters have been set in the Security &gt; Secrets &gt; Actions menu on the Settings tab of the repository. Once they are defined, they can be used in the following way $. . . Docker Hub &#8617; . | Composite action #4 &#8617; . | GitHub Action - Build and push Docker images &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/github%20action/2022/07/25/action-time-improvement.html",
            "relUrl": "/github%20action/2022/07/25/action-time-improvement.html",
            "date": " • Jul 25, 2022"
        }
        
    
  
    
        ,"post13": {
            "title": "▸ Week 7 Summary",
            "content": "Introduction . This post is meant to be a reference for the work I’ve done during the seventh week. . Week 7 . I have spent most of this week’s time working on the RcppDeepState GitHub Action. As discussed in my previous blog post1 I decided to integrate the actual docker based action with a composite one. Thanks to the precious advices of my mentors, I have performed this update, moving the actual docker architecture to the docker folder of the repository and creating a new action.yml file for the composite architecture. In this way the final result is a more flexible action that can be easily integrated with other actions available on the marketplace. In particular I have done the following improvements: . artifact upload: the results of RcppDeepState analysis are compressed in a zip file and uploaded as an artifact file to GitHub. By doing this, the user can easily download the analysis results and check the logs, inputs and outputs; | comment on pull request: the table that is returned by the analysis step can be printed in the pull requests if the comment parameter of the action is set to true. Here is a example of a comment message | . function_name message file_line address_trace . rcpp_read_out_of_bound | Invalid read of size 4 | read_out_of_bound.cpp:7 | No Address Trace found | . rcpp_use_after_deallocate | Invalid read of size 1 | use_after_deallocate.cpp:8 | use_after_deallocate.cpp:6 | . rcpp_use_after_free | Invalid read of size 4 | use_after_free.cpp:8 | use_after_free.cpp:6 | . rcpp_write_index_outofbound | Invalid write of size 4 | write_index_outofbound.cpp:8 | No Address Trace found | . rcpp_zero_sized_array | Invalid write of size 4 | zero_sized_array.cpp:8 | zero_sized_array.cpp:7 | . new fail_ci_if_error parameter: allows developers to define whether the workflow should fail if at least one error is found by RcppDeepState; | . In terms of RcppDeepState, I improved the harness creation procedure by deleting some superfluous if/else lines and reorganizing all the information for each supported datatype into a data.table structure. . Reference . Pull requests: . Logging improvements | Composite action | . Blog posts: . Moving to a composite GitHub Action | . . Moving to a composite GitHub Action &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/summary/2022/07/16/week-7.html",
            "relUrl": "/summary/2022/07/16/week-7.html",
            "date": " • Jul 16, 2022"
        }
        
    
  
    
        ,"post14": {
            "title": "Moving to a composite GitHub Action",
            "content": "Introduction . In the fifth week of work I’ve created a first working prototype of the GitHub Action for RcppDeepState, based on the considerations that I published in the dedicated blog post1. Within this post, I discussed three different architectures that might be used when creating a GitHub Action. Among the three possibilities, I selected to develop a GitHub action based on Docker. . However, in the pull request for the Action’s initial prototype, I indicated the potential of switching from a Docker Action to a Composite Action2: . “In the future, I’ll also think about if I can express this Action as a composite action.” . Docker system motivation . The key reason for using a Docker-based system is that it enables for the creation of a fully customized environment in which RcppDeepState will execute. This allows me to install only the essential tools and configure the environment such that RcppDeepState fits in. In particular the idea came by the fact that RcppDeepState requires that optimization options must be disabled in the system in order to work with it’s maximum performance. Furthermore, because RcppDeepState can only be executed on Linux-based computers, limiting it to a Docker system based on a Linux container is a reasonable option. . Problem . However, not everything works well with the Docker system since it lacks the final user interaction. This is a crucial consideration because it is what the final user will see. If the user is unable to detect or rapidly identify the errors in a package, the entire Action will be useless. Using the docker architecture, the action can only print the results in the log in text format, without allowing the results to be uploaded as an artifact file and shared with other steps/jobs in the workflow. . Solution . Starting with this I searched for a solution to the problem and discovered that actions/upload-artifact allows to share the analysis findings with other jobs by publishing an artifact file. The actions/upload-artifact would be handy for RcppDeepState since it may be configured to upload the analyzed package’s ‘inst/testfiles’ folder, which contains the inputs as well as the Valgrind outputs of the RcppDeepState execution. . The issue is that publishing an artifact file via the Docker system is a challenging operation. One possibility is to combine the present Docker system with a Composite Action to gain the benefits of both systems. Thus in this week of work(seventh week) I will integrate the existing docker system with a composite action. The primary action will be the composite one, and the docker action will be triggered by a composite step. . . RcppDeepState’s GitHub Action considerations &#8617; . | First prototype &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/github%20action/2022/07/11/move-to-composite.html",
            "relUrl": "/github%20action/2022/07/11/move-to-composite.html",
            "date": " • Jul 11, 2022"
        }
        
    
  
    
        ,"post15": {
            "title": "▸ Week 6 Summary",
            "content": "Introduction . This post is meant to be a reference for the work I’ve done during the sixth week. . Week 6 . After the creation of a RcppDeepState GitHub Action prototype of the previous week, I managed to organize my week spending some time working on RcppDeepState and the rest of the time improving the existing GitHub Action prototype. . RcppDeepState . I started by doing some improvements to the RcppDeepState’s logs, printing for each function not analyzed, the list of parameters that fall out of the allowed list. I also added a verbose parameter to all the functions that generates some textual output. This option is used to offer more detailed information if set to TRUE. . Additionally, I discovered that RcppDeepState did not execute the analysis of a package containing a function with an argument of type Rcpp::String since this datatype is not one that is supported. To fill this gap, I added a method that creates a random Rcpp::String to the RcppDeepState.h header file. . RcppDeepState Action . On the Action side, I implemented the exit codes allowing the Action to report a fail status if the RcppDeepState’s analysis discovers any issues. If no errors have been detected, the analysis script produces a status code of 0, and if at least one issue has been discovered by RcppDeepState, it returns a status code of 1. . I also extended the Action’s input arguments, providing programmers more flexibility over the RcppDeepState options. The following input parameters have been introduced . seed: input parameter that will be used as an input seed for deterministic fuzz testing; | time_limit: used to control the time which the fuzzing phase will be run; | max_inputs: used to provide a maximum number of inputs to analyze | . Reference . Pull requests: . Harness creation improvements | Logging improvements | Rcpp string support | First prototype | Exit codes | Input arguments | . Issues: . Missing Rcpp Strings support | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/summary/2022/07/08/week-6.html",
            "relUrl": "/summary/2022/07/08/week-6.html",
            "date": " • Jul 8, 2022"
        }
        
    
  
    
        ,"post16": {
            "title": "▸ Week 5 Summary - GitHub Action prototype",
            "content": "Introduction . This post is meant to be a reference for the work I’ve done during the fifth week. . Week 5 . The primary goal of this week was to finish the first working prototype of the RcppDeepState’s GitHub Action. The requirements analysis was the first step, therefore I produced a blog article to serve as a reminder of key things to think about before moving on to the effective development phase. I then started working on the Action’s actual implementation, writing a basic structure based on a Docker Action. Then I made some improvements, by adding a location argument that allows to run RcppDeepState in repositories where the package that needs to be analyzed isn’t in the root folder. Finally I created a workflow to test the Action and see the output results. In the meanwhile I continued working on the RcppDeepState library. . Reference . Blog posts: . RcppDeepState’s GitHub Action considerations | . Pull requests: . Debug symbols tests | Harness creation improvements | First prototype | . Issues: . RcppDeepState optimization options | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/summary/2022/07/01/week-5.html",
            "relUrl": "/summary/2022/07/01/week-5.html",
            "date": " • Jul 1, 2022"
        }
        
    
  
    
        ,"post17": {
            "title": "RcppDeepState's GitHub Action considerations",
            "content": "Introduction . Continuous integration and Continuous delivery, also called CI/CD, are two useful methodologies that every developer have hear about. This terms refers to the possibility of continuously perform some task with your code in an automated way. . Continuous integration, often, relies on executing automatic testing to check that an application is correctly behaving. On the other hand, continuous delivery refers to the process of automatically move the code from a testing environment to a production environment. . These two methodologies, can be implemented in any Git repository using tools such as GitHub Actions and TravisCI. I will focus only on GitHub Actions, which is a feature implemented by the GitHub platform, which allows to create complex workflows in any kind of repository. . GitHub Actions . GitHub actions are fully integrated with GitHub and can respond to any specified GitHub event (new issue, pull request, push on a branch). This is a fully automated engine and GitHub Actions comes with a lot of pre-defined workflows that are provided by communities. A powerful functionality provided by GitHub actions is the possibility to run the code on different operating systems, such as Linux, Windows, macOS and Docker containers. . GitHub Actions are composed of three components: an event, a workflow and an action. Everything start with an event that triggers the execution of a workflow, which is composed of different jobs to compute some operations. Actions instead are reusable units of code that are called within a workflow with the with parameter. . Github Actions and RcppDeepState . In the previous posts, I demonstrated the efficacy of RcppDeepState in detecting issues in Rcpp-based libraries. Based on this, in order to make it easier for developers to execute RcppDeepState on any R package hosted in a GitHub repository, it will be useful to integrate RcppDeepState inside a GitHub Action. This is exactly the main goal of my Google Summer Of Code project, but before getting started on the development of the GitHub Action, there are a few things to take into account. . Considerations . Here is a list of considerations that will help me during the development of the RcppDeepState GitHub Action. . The first thing I need to take into account is the choice of the architecture for the GitHub Action. According to the GitHub documentation1 there are three ways to create an Action: Docker container Action | Javascript Action | Composite Action | . | While developing the Action I need to consider that all the optimization parameters must be disabled in order to get the best performance of RcppDeepState. The motivation behind this choice is explained in the Issue #8. | Define the inputs and the outputs of the Action. | The Action will likely be published on the GitHub Marketplace in the future so that developers can easily find it on the GitHub platform. As a result, I decided it would be better to build it in a different repository. This will, as stated in the documentation2, decouple the versioning of the action from the versioning of the RcppDeepState application code. If you’re developing an action for other people to use, we recommend keeping the action in its own repository instead of bundling it with other application code. This allows you to version, track, and release the action just like any other software. . Storing an action in its own repository makes it easier for the GitHub community to discover the action, narrows the scope of the code base for developers fixing issues and extending the action, and decouples the action’s versioning from the versioning of other application code. . | Development . As mentioned in the Considerations section, this GitHub Action will be entirely developed in a separate repository that can be found at the following link: RcppDeepState-action. . GitHub documentation: Creating actions &#8617; . | GitHub documentation: Choosing a location for your action &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/github%20action/2022/06/28/github-actions.html",
            "relUrl": "/github%20action/2022/06/28/github-actions.html",
            "date": " • Jun 28, 2022"
        }
        
    
  
    
        ,"post18": {
            "title": "▸ Week 4 & Community Bonding Period - First changes to RcppDeepState",
            "content": "Introduction . This post is meant to be a reference for the work I’ve done in the Community Bonding Period and the first coding period’s first week. . Weeks 1-3 (Community Bonding Period) . I spent this three weeks of Community Bonding Period interacting with my mentors, familiarizing myself with the tools and working on high priority tasks. . Using this blog as a way to familiarize myself with the tools, I started working with DeepState, showing some basic examples and moving step by step with more complex one. Then I gave a brief introduction to Valgrind and showed how it might be used in conjunction with DeepState to produce a sophisticated fuzz testing toolbox. When these three powerful tools —Valgrind, DeepState, and Rcpp— were integrated, I introduced Rcpp and finally RcppDeepState. . Reference . Blog posts: . Sample DeepState fuzz test | DeepState introduction | Advanced fuzz testing with DeepState and Valgrind | Introduction to RcppDeepState | Rcpp package fuzz testing with RcppDeepState | . Pull requests: . Makefile generation fix and improvements | Override default Makevars | Harness creation improvements | . Issues: . Segmentation fault not catched | Fuzzing functions with Rcpp parameters | . External issues: . Unexpected Segmentation Fault | . Week 4 . I have spent the most of this first week focusing on some important tasks that I discovered during the Community Bonding Period. Everything specifically began when I discovered that debug symbols were not present by default on some systems. This led to the creation of the Makevars file inside the src directory of each package, before R CMD INSTALL is run. Based on this I created a custom workflow to check if debug symbols are included by default or not on the system. I discovered several bugs in the RcppDeepState library while developing this workflow and was able to effectively fix them. . A detailed description of the changes and problems I encountered in this first week can be found in pull request #6. I report some of them here: . solved the problem that on some platforms debug symbols are not included by default; | solved some problems with RInside. In detail I moved the definition of RInside outside of the TEST function in order to preserve the seeds and to avoid the R is already initialized error; | implemented the possibility to add a seed argument to the deepstate_harness_compile_run function; | solved the problem of the Segmentation fault that prevented DeepState to create the output files; | Reference . Blog posts: . Debugging Rcpp outside of R | Deterministic fuzz testing with DeepState and Rcpp | . Pull requests: . Debug symbols tests | . Issues: . Valgrind for initial pass | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/summary/2022/06/24/first-week.html",
            "relUrl": "/summary/2022/06/24/first-week.html",
            "date": " • Jun 24, 2022"
        }
        
    
  
    
        ,"post19": {
            "title": "Deterministic fuzz testing with DeepState and Rcpp",
            "content": "Motivation . While searching for a way to perform non deterministic fuzz testing (using some kind of seeds) to be used in the workflow for the pull request #6, I discovered that the seed would not work if the RInside declaration is made inside the TEST macro of the test Harness. Let’s have a look at an example. . Example . Recall to the example of the previous post, where we wanted to perform fuzz testing on a simple Rcpp function that takes an integer vector as input and returns the first element. Let’s say we want to discover a seed that will allow us to replicate the DeepState inputs throughout several executions, in a way that the execution will be deterministic. Let’s add a cout at line 36 in order to observe the inputs generated by DeepState. . #include &lt;iostream&gt; #include &lt;Rcpp.h&gt; #include &lt;RInside.h&gt; #include &lt;deepstate/DeepState.hpp&gt; using namespace deepstate; // [[Rcpp::export]] int getFirstElement(Rcpp::IntegerVector v) { if (v.size() != 0){ return v[0]; } return -1; } // random IntegerVector generation procedure Rcpp::IntegerVector randomIntegerVector(int maxSize){ int size = DeepState_IntInRange(1,maxSize); Rcpp::IntegerVector vec(size); for (int i=0; i&lt;size; i++){ vec[i] = DeepState_IntInRange(0,1000); } return vec; } TEST(Unit, name){ static RInside R; Rcpp::IntegerVector randomVec = randomIntegerVector(20); std::cout &lt;&lt; randomVec &lt;&lt; std::endl; getFirstElement(randomVec); } . The result will change across several executions regardless of whether this harness is executed using the --seed=1 argument. The first ten lines of output from two distinct runs are shown below, and it appears that the seed option has no influence on the produced input. . $ ./getFirstElement --fuzz --timeout=1 --seed=1 | head INFO: Starting fuzzing WARNING: No test specified, defaulting to first test defined (Unit_name) 808 622 869 877 455 672 774 844 240 910 915 474 182 907 28 1000 921 295 168 356 675 825 344 511 36 735 784 573 715 622 338 351 542 750 202 746 817 227 9 588 973 14 4 194 627 987 249 578 315 275 415 918 1 777 966 69 806 69 559 978 421 300 867 214 429 872 755 856 345 993 722 942 378 593 210 780 393 760 430 106 400 846 144 767 669 263 278 872 625 265 58 203 89 832 969 144 952 266 192 975 327 386 816 946 35 $ ./getFirstElement --fuzz --timeout=1 --seed=1 | head INFO: Starting fuzzing WARNING: No test specified, defaulting to first test defined (Unit_name) 657 470 974 648 599 658 812 515 388 162 698 87 20 672 429 355 22 104 1000 742 779 948 157 630 840 336 616 666 220 185 76 965 220 18 531 484 232 85 76 959 388 473 630 390 997 619 474 386 449 650 255 520 717 909 775 783 249 75 988 668 422 595 767 182 417 60 691 783 972 996 740 220 732 19 390 253 704 89 329 815 520 122 600 111 27 796 541 591 778 352 673 205 195 526 73 318 380 155 221 972 540 668 985 462 953 175 . Solution . This peculiar behavior, I discovered, is caused by the RInside statement within the TEST macro. The seed will work if the above program is modified by shifting the RInside declaration to the beginning and deleting the static keyword. . #include &lt;iostream&gt; #include &lt;Rcpp.h&gt; #include &lt;RInside.h&gt; #include &lt;deepstate/DeepState.hpp&gt; using namespace deepstate; RInside Rinstance; // [[Rcpp::export]] int getFirstElement(Rcpp::IntegerVector v) { if (v.size() != 0){ return v[0]; } return -1; } // random IntegerVector generation procedure Rcpp::IntegerVector randomIntegerVector(int maxSize){ int size = DeepState_IntInRange(1,maxSize); Rcpp::IntegerVector vec(size); for (int i=0; i&lt;size; i++){ vec[i] = DeepState_IntInRange(0,1000); } return vec; } TEST(Unit, name){ Rcpp::IntegerVector randomVec = randomIntegerVector(20); std::cout &lt;&lt; randomVec &lt;&lt; std::endl; getFirstElement(randomVec); } . The output will now remain the same over multiple executions . $ ./getFirstElement --fuzz --timeout=1 --seed=1 | head INFO: Starting fuzzing WARNING: No test specified, defaulting to first test defined (Unit_name) 45 876 469 501 681 966 606 500 505 917 974 278 278 134 30 89 629 63 662 549 902 171 509 314 370 622 287 508 904 960 320 971 431 402 436 155 610 425 643 826 670 136 877 558 789 66 681 315 4 29 888 577 658 499 191 348 959 539 740 712 152 704 460 449 727 889 811 54 456 168 891 196 561 467 544 254 942 911 256 663 578 517 845 159 167 671 342 887 546 605 607 354 881 361 545 865 588 312 649 123 750 729 474 863 43 482 $ ./getFirstElement --fuzz --timeout=1 --seed=1 | head INFO: Starting fuzzing WARNING: No test specified, defaulting to first test defined (Unit_name) 45 876 469 501 681 966 606 500 505 917 974 278 278 134 30 89 629 63 662 549 902 171 509 314 370 622 287 508 904 960 320 971 431 402 436 155 610 425 643 826 670 136 877 558 789 66 681 315 4 29 888 577 658 499 191 348 959 539 740 712 152 704 460 449 727 889 811 54 456 168 891 196 561 467 544 254 942 911 256 663 578 517 845 159 167 671 342 887 546 605 607 354 881 361 545 865 588 312 649 123 750 729 474 863 43 482 . This problem is resolved in the pull request #6. .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/deepstate/rcpp/2022/06/21/deterministic-fuzz-testing.html",
            "relUrl": "/deepstate/rcpp/2022/06/21/deterministic-fuzz-testing.html",
            "date": " • Jun 21, 2022"
        }
        
    
  
    
        ,"post20": {
            "title": "Debugging Rcpp outside of R",
            "content": "Introduction . Sometimes it could be necessary to test your Rcpp defined code using an external tool, like Valgrind or GDB. This process however will almost likely come to a crash of your program with a strange Segmentation Fault error. The error is due to the fact that executing Rcpp code is only possible within a working R environment. I talked about this with a Rcpp community member and his answer is reported in this issue #1221. . “All” that Rcpp does is to provide R with callable code via the .Call() interface which is meant to extend a running R session. Nowhere in the R (or Rcpp) documentation is it hinted that you can run code separately. Which is why we run all tests etc from R. . So, the question might appear straightforward, but is it feasible to run Rcpp code outside of a R environment? Using RInside, the answer is yes. . Proof of concept . Imagine you have the following bootstrap function and want to simply execute it and get the result, that you expect to be 10. . #include &lt;iostream&gt; #include &lt;Rcpp.h&gt; // [[Rcpp::export]] int bootstrap() { // Allocate a sample NumericVector Rcpp::NumericVector sample {10,20,30,40,50}; return sample[0]; } int main(int argc, char* argv[]){ std::cout &lt;&lt; bootstrap() std::endl; return 0; } . If you try to compile and execute this program however the result is quite different: . $ g++ -lR -I&quot;/usr/include/R/&quot; -I/usr/local/include -I&quot;/home/fabri/R/x86_64-pc-linux-gnu-library/4.2/Rcpp/include&quot; -L/usr/lib64/R/lib -o bootstrap bootstrap.cpp $ ./bootstrap [1] 23848 segmentation fault (core dumped) ./bootstrap . Solution . The solution is to embed in your code a working R environment within the process. This can be done using the powerful RInside library. All you have to do is to include the header files and create an embedded R instance. The preceding example will be modified as follows: . #include &lt;iostream&gt; #include &lt;Rcpp.h&gt; #include &lt;RInside.h&gt; // [[Rcpp::export]] int bootstrap() { RInside R; // Allocate a sample NumericVector Rcpp::NumericVector sample {10,20,30,40,50}; return sample[0]; } int main(int argc, char* argv[]){ std::cout &lt;&lt; bootstrap() std::endl; return 0; } . There will be no errors if you try to compile and run the program after this update. . $ g++ -g -lR -lRInside -I&quot;/usr/include/R/&quot; -I/usr/local/include -I/usr/lib/R/library/RInside/include -I&quot;/home/fabri/R/x86_64-pc-linux-gnu-library/4.2/Rcpp/include&quot; -L/usr/lib/R/library/RInside/lib -Wl,-rpath=/usr/lib/R/library/RInside/lib -L/usr/lib64/R/lib -o bootstrap bootstrap.cpp $ ./bootstrap 10 . Debugging with Deepstate and valgrind . Now that we have all of the necessary tools, we can start developing our first Rcpp function test harness. Imagine that we want to fuzz test a function named getFirstElement that returns the first element of an Rcpp IntegerVector. Deepstate might be used to send some randomly initialized vectors to this method in order to discover any memory issues. To do this, we may create a basic test harness that employs a function that produces a random integer vector, in this instance randomIntegerVector, and then passes that vector to the getFirstElement function. This is the final result. . #include &lt;iostream&gt; #include &lt;Rcpp.h&gt; #include &lt;RInside.h&gt; #include &lt;deepstate/DeepState.hpp&gt; using namespace deepstate; // [[Rcpp::export]] int getFirstElement(Rcpp::IntegerVector v) { if (v.size() != 0){ return v[0]; } return -1; } // random IntegerVector generation procedure Rcpp::IntegerVector randomIntegerVector(int maxSize){ int size = DeepState_IntInRange(1,maxSize); Rcpp::IntegerVector vec(size); for (int i=0; i&lt;size; i++){ vec[i] = DeepState_IntInRange(0,1000); } return vec; } TEST(Unit, name){ static RInside R; Rcpp::IntegerVector randomVec = randomIntegerVector(20); getFirstElement(randomVec); } . It’s worth noting that the RInside instance has been defined as static, this will prevent error such as R is already initialized. Making the R variable static force the application to use the same RInside object for all of the application’s lifetime. . Let’s now compile the harness and run it with the Valgrind Memcheck tool . $ g++ -g -ldeepstate -lR -lRInside -I&quot;/usr/include/R/&quot; -I/usr/local/include -I/usr/lib/R/library/RInside/include -I&quot;/home/fabri/R/x86_64-pc-linux-gnu-library/4.2/Rcpp/include&quot; -L/usr/lib/R/library/RInside/lib -Wl,-rpath=/usr/lib/R/library/RInside/lib -L/usr/lib64/R/lib -o getFirstElement getFirstElement.cpp $ valgrind ./getFirstElement --fuzz --timeout=10 . This will be the result . ==43210== Memcheck, a memory error detector ==43210== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al. ==43210== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info ==43210== Command: ./getFirstElement --fuzz --timeout=10 ==43210== INFO: Starting fuzzing WARNING: No seed provided; using 1654880923 WARNING: No test specified, defaulting to first test defined (Unit_name) INFO: Done fuzzing! Ran 1828 tests (182 tests/second) with 0 failed/1828 passed/0 abandoned tests ==43210== ==43210== HEAP SUMMARY: ==43210== in use at exit: 51,299,862 bytes in 9,936 blocks ==43210== total heap usage: 30,813 allocs, 20,877 frees, 87,993,209 bytes allocated ==43210== ==43210== LEAK SUMMARY: ==43210== definitely lost: 0 bytes in 0 blocks ==43210== indirectly lost: 0 bytes in 0 blocks ==43210== possibly lost: 0 bytes in 0 blocks ==43210== still reachable: 51,299,862 bytes in 9,936 blocks ==43210== of which reachable via heuristic: ==43210== newarray : 4,264 bytes in 1 blocks ==43210== suppressed: 0 bytes in 0 blocks ==43210== Rerun with --leak-check=full to see details of leaked memory ==43210== ==43210== For lists of detected and suppressed errors, rerun with: -s ==43210== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) . Conclusion . We were able to run a debugging tool, specifically the Valgrind suite’s Memcheck tool. This demonstrates how integrating many techniques may be an effective method of solving a problem. .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/rcpp/valgrind/2022/06/10/rcpp-debugging.html",
            "relUrl": "/rcpp/valgrind/2022/06/10/rcpp-debugging.html",
            "date": " • Jun 10, 2022"
        }
        
    
  
    
        ,"post21": {
            "title": "Rcpp package fuzz testing with RcppDeepState",
            "content": "Automated fuzz testing . We saw how to manually create a Test Harness for a Rcpp written function in order to run fuzz testing on it in the previous blog article. In practice, this strategy is never used: the majority of the time, the Harness construction process is automated. This is what we’ll talk about in this blog article. . The steps . The RcppDeepState library was introduced in the previous post to do package fuzz testing. This library includes a collection of features that allow you to construct the test harness for a certain package function automatically. . RccpDeepState includes the following two key functions: . deepstate_harness_compile_run | deepstate_harness_analyze_pkg | . Let’s take a closer look at them. . The compilation procedure . The function deepstate_harness_compile_run(package_path) is used to run the compilation process, and it accepts the location of the library we want to fuzz test. . This step begins by looking for any Rcpp written functions in the supplied library. This is accomplished by looking for information about the package’s exported functions, which are found in the RcppExports.cpp file in the src source folder. Once you’ve gathered all of the data, you’ll need to construct a test harness file. This phase is done by deepstate_pkg_create, which generates a Harness file for each function discovered in &lt;package_dir&gt;/inst/testfiles/&lt;function_name&gt;. This file includes the headers as well as the ‘TEST’ function definition, which includes all of the symbolic variables. . Using the R CMD INSTALL command, a shared object for the library is also produced (.so file). It’s worth noting that the shared object must be compiled with the -g option in order to include debug symbols. I discovered that the shared object was produced without debugging symbols on some Linux systems. I wrote an additional piece of code to rewrite the Makevars file holding the compilation parameters in order to solve the problem. This issue is solved in the Pull request #3. . The fuzz testing approach begins once the library and harness have been generated: the output of the tests is stored in order to evaluate them later using Valgrind. . The analysis phase . Following the completion of the fuzz testing, the next step is to analyze the inputs generated. This is done using deepstate_harness_analyze_pkg(package_path). This function looks for binary files containing the inputs in the &lt;package_dir&gt;/inst/testfiles directory. The harness is then rerun with the --input_test_file option: this allows to provide an input test case. It’s worth noting that in this second stage, the harness is examined by the Valgrind Memcheck tool, resulting in an XML log file. . RcppDeepState then parses this file for error information (message, line number, etc.) and returns them to the deepstate_harness_analyze_pkg(package_path) function. . Example . RcppDeepState includes a sample library under the RcppDeepState/inst/testpkgs/testSAN folder. It can be useful as a toy library for detecting problems. Following the approach outlined in the previous part, we examine the package in this section. . The first step is to use deepstate_harness_compile_run to compile the library. This function prints a list of successfully constructed harness when the compilation processes are done. In this example, all of the functions were appropriately built. On the other hand, if any functions are not built, an error message is generated. . &gt; deepstate_harness_compile_run(&quot;RcppDeepState/inst/testpkgs/testSAN&quot;) ... compilation steps ... [1] &quot;rcpp_read_out_of_bound&quot; &quot;rcpp_use_after_deallocate&quot; [3] &quot;rcpp_use_after_free&quot; &quot;rcpp_use_uninitialized&quot; [5] &quot;rcpp_write_index_outofbound&quot; &quot;rcpp_zero_sized_array&quot; . The next step is to use Valgrind’s Memcheck tool to perform the analysis. . &gt; result &lt;- deepstate_harness_analyze_pkg(&quot;RcppDeepState/inst/testpkgs/testSAN&quot;) . We may get a detailed description of the faults detected by printing the contents of result$logtable : . &gt; knitr::kable(result$logtable) |err.kind |message |file.line |address.msg |address.trace | |:--|:-|:-|:--|:-| |InvalidRead |Invalid read of size 1 |use_after_deallocate.cpp : 8 |Address 0x806cfe5 is 5 bytes after a block of size 0 free&#39;d |use_after_deallocate.cpp : 6 | |InvalidRead |Invalid read of size 1 |use_after_deallocate.cpp : 7 |Address 0x806cfe5 is 5 bytes after a block of size 0 free&#39;d |use_after_deallocate.cpp : 6 | |err.kind |message |file.line |address.msg |address.trace | |:--|:-|:-|:--|:-| |InvalidRead |Invalid read of size 1 |use_after_deallocate.cpp : 8 |Address 0x806cfe5 is 5 bytes after a block of size 0 free&#39;d |use_after_deallocate.cpp : 6 | |InvalidRead |Invalid read of size 1 |use_after_deallocate.cpp : 7 |Address 0x806cfe5 is 5 bytes after a block of size 0 free&#39;d |use_after_deallocate.cpp : 6 | |err.kind |message |file.line |address.msg |address.trace | |:--|:-|:-|:--|:-| |InvalidRead |Invalid read of size 1 |use_after_deallocate.cpp : 8 |Address 0x806cfe5 is 5 bytes after a block of size 0 free&#39;d |use_after_deallocate.cpp : 6 | |InvalidRead |Invalid read of size 1 |use_after_deallocate.cpp : 7 |Address 0x806cfe5 is 5 bytes after a block of size 0 free&#39;d |use_after_deallocate.cpp : 6 | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/rcppdeepstate/2022/06/07/rcppdeepstate-automatic-fuzz-testing-copy.html",
            "relUrl": "/rcppdeepstate/2022/06/07/rcppdeepstate-automatic-fuzz-testing-copy.html",
            "date": " • Jun 7, 2022"
        }
        
    
  
    
        ,"post22": {
            "title": "Introduction to RcppDeepState",
            "content": "Introduction to RcppDeepState . In previous posts, we’ve shown how to use DeepState in conjunction with Valgrind to create a tool that can detect more subtle programming errors in the code. In this post, we’ll introduce RcppDeepState, which will add another brick to this toolkit. . Rcpp . The Rcpp package1 gives R developers a way to write C++ code for some of its modules. It’s sometimes useful to write C++ code in place of R functions; it’s a performance trade-off. It has been demonstrated that R is particularly inefficient in computing recursive functions when compared to C++. . It’s not the purpose of this article to discuss the Rcpp library, however what you need to know in order to continue is that Rcpp allows to call some external C++ functions exported to the R environment by tagging them with the // [[Rcpp::export]] comment on top of them. . Installation . The installation of the library is quite a straightforward task since the package is available on CRAN. . install.packages(&quot;Rcpp&quot;) . Sample usage . Let’s look at a simple example of a Fibonacci recursive function written in C++ and exported to the R environment to have a better idea of how Rcpp works. Let’s start with a C++ definition of the Fibonacci function. . int fibonacci(int n) { if (n &lt;= 1) return 1; return fib(n-1) + fib(n-2); } . The first step to integrate this function with the R environment is to include the appropriate header of Rcpp with it’s associated namespace. The final step is to export the fibonacci function. As mentioned earlier to do this we use the // [[Rcpp::export]] comment. By doing this way, the R environment can easily understand which function should be exported. The final result should look somewhat like this: . #include &lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] int fibonacci(int n) { if (n &lt;= 1) return 1; return fibonacci(n-1) + fibonacci(n-2); } . We don’t need to compile anything in order for this function to work; all we have to do in our R environment is include the appropriate library and call the sourcCpp function. This function automatically compiles the C++ code and sources it into the running environment, in the same way the standard source function works. . &gt; require(&quot;Rcpp&quot;) &gt; sourceCpp(&quot;./fibonacci.cpp&quot;) &gt; fibonacci(5) [1] 8 . Rcpp based package . In the previous example we ran a single C++ file, however most of the times Rcpp is bundled inside packages. This allows users to use this packages without actually having any C++ development tool. To initialize a package using Rcpp, we use the Rcpp.package.skeleton function. If you want to generate a package based on the previous Rcpp fibonacci script, simply supply a list of C++ files to the skeleton function’s cpp_files parameter. . Rcpp.package.skeleton(&quot;Fibonacci&quot;, example_code = FALSE, cpp_files = c(&quot;fibonacci.cpp&quot;)) . This way we end up with a folder containing a working Rcpp based module: . Rcpp source file are located in src | R files are located in R | Rd documentation files are located in man | . RcppDeepState . Let’s get started with the main topic of this article: RcppDeepState. RcppDeepState is a combination of three different tools: Rcpp, DeepState, and Valgrind. RcppDeepState’s purpose is to perform fuzz testing on Rcpp-based modules. The related work is restricted to R-level fuzzing and does not include fuzz testing of compiled C++ code developed with Rcpp. The lack of such support for fuzz testing led Akhila Chowdary 2 to create such a powerful tool. . Installation process . Since RcppDeepState is not available on CRAN, it must be installed manually. We can use the traditional devtools way to download the package from the official repository and install it: . install.packages(&quot;devtools&quot;) require(&quot;devtools&quot;) devtools::install_github(&quot;akhikolla/RcppDeepState&quot;) . In alternative it’s possible to directly download the source and install the package from a working R environment: . install.packages(&quot;/path/to/RcppDeepState&quot;, repos = NULL, type=&quot;source&quot;) . Steps . In order to perform fuzz testing, RcppDeepState follows the same steps we have used in the previous posts, with a few more steps in between: . find the exported Rcpp functions | DeepState test harness creation | package analysis using Valgrind | . Some steps are left out, such as the automatic test harness creation. We will see this later on in another post. . RcppDeepState auxiliary functions . The objective of RcppDeepState is to create a link between Rcpp and DeepState in order to perform fuzz testing. This can be done by using some C++ auxiliary function that initializes all the necessary symbolic variables. Symbolic variables were already discussed in a previous article 3. . A list of common auxiliary functions is reported in the following list: . RcppDeepState_int(): generates an integer symbolic variable. Optionally, the parameters int low, int high can be used to restrict the generated numbers in a range | RcppDeepState_double(): generates a double symbolic variable. Optionally, the parameters double low, double high can be used to restrict the generated numbers in a range | RcppDeepState_IntegerVector: generates a vector of integers with a size in the range 0-100 (inclusive). Optionally, the parameters int size, int low, int high can be used to specify the vector size and to restrict the generated numbers in a range. | RcppDeepState_NumericVector(): generates a vector of doubles with a size in the range 0-100 (inclusive). Optionally, the parameters int size, int low, int high can be used to specify the vector size and to restrict the generated numbers in a range. | RcppDeepState_NumericMatrix(): generates a matrix of doubles with a size in the range (rows=0,cols=0) and (10,10). Optionally, the parameters int row,int column,int low,int high can be used to specify the matrix size (in terms of rows and cols) and to restrict the generated numbers in a range. | RcppDeepState_CharacterVector(): generates a vector of characters with a size in the range 0-100 (inclusive). | RcppDeepState_string(): generates a string of a length up to 26 characters taken from the alphabet. | . This functions can be used in the test harness TEST procedure. Let’s use an example to further understand this. . RcppDeepState TestHarness sample . RcppDeepState has an automated test harness generation function, deepstate_harness_create(). However, we manually create a TestHarness using the auxiliary functions indicated above in order to understand how RcppDeepState works behind the scenes. . Assume you have a leaked function that takes an integer as an input and allocates some Heap memory to it. Consider the case where the developer failed to free the used memory if the integer parameter is more than 500. Imagine that for some strange motivation the developer forgot to free the used memory if the integer parameter is greater than 500 for some strange reason. The following is an example of the function: . void copyAndFreeVector(int source){ // allocates some space for 1 integer int* sample = (int*) malloc(sizeof(int)); if (source &lt; 500){ free(sample); } } . A TestHarness can be generated for this program, using the auxiliary functions above. It can be simply done by creating a symbolic integer variable, initialized using the appropriate RcppDeepState_int(int low, int high) function. As you can see, in order to work with Rcpp and RcppDeepState you need to include the necessary libraries. . #include &lt;deepstate/DeepState.hpp&gt; #include &lt;Rcpp.h&gt; #include &lt;RcppDeepState.h&gt; using namespace deepstate; // [[Rcpp::export]] void copyAndFreeVector(int source){ // allocates some space for 1 integer int* sample = (int*) malloc(sizeof(int)); if (source &lt; 500){ free(sample); } } TEST(IntAllocation, AllocateIntegerWithoutFree) { int v = RcppDeepState_int(0, 1000); copyAndFreeVector(v); } . Now that the test harness is completed we can compile it, and run the fuzz testing with Valgrind. The compilation needs a lot of library and headers inclusion in order to properly work. We need to include the headers files for R, Rcpp, RcppDeepState and RcppArmadillo. In addition we need to specify to g++ where to find the shared objects (.so files) for R and RInside. The -g option is included to add more debugging information to the compiled binary, which is worth mentioning. . g++ -I/usr/include/R -I/usr/lib/R/library/Rcpp/include -I/usr/lib/R/library/RcppDeepState/include -I/usr/lib/R/library/RcppArmadillo/include -L/usr/lib64/R/lib -L/usr/lib/R/library/RInside/lib -lR -lRInside -ldeepstate -o program -g program.cpp . The last step is to run the compiled program using Valgrind with the --leak-check=full option in order to find memory leaks. . valgrind --leak-check=full ./program --fuzz --timeout=1 . This is the result . ==29579== Memcheck, a memory error detector ==29579== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al. ==29579== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info ==29579== Command: ./program --fuzz --timeout=1 ==29579== INFO: Starting fuzzing WARNING: No seed provided; using 1653991738 WARNING: No test specified, defaulting to first test defined (IntAllocation_AllocateIntegerWithoutFree) INFO: Done fuzzing! Ran 11711 tests (11711 tests/second) with 0 failed/11711 passed/0 abandoned tests ==29579== ==29579== HEAP SUMMARY: ==29579== in use at exit: 23,544 bytes in 5,885 blocks ==29579== total heap usage: 11,735 allocs, 5,850 frees, 165,956 bytes allocated ==29579== ==29579== 23,536 bytes in 5,884 blocks are definitely lost in loss record 2 of 2 ==29579== at 0x4845888: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==29579== by 0x11B414: copyAndFreeVector(int) (program.cpp:10) ==29579== by 0x11B484: DeepState_Test_IntAllocation_AllocateIntegerWithoutFree() (program.cpp:18) ==29579== by 0x11B439: DeepState_Run_IntAllocation_AllocateIntegerWithoutFree() (program.cpp:16) ==29579== by 0x113130: DeepState_RunTestNoFork (in /home/fabri/test/testHarness/RcppTestHarness/program) ==29579== by 0x113654: DeepState_FuzzOneTestCase (in /home/fabri/test/testHarness/RcppTestHarness/program) ==29579== by 0x1138E7: DeepState_Fuzz (in /home/fabri/test/testHarness/RcppTestHarness/program) ==29579== by 0x10EDAA: main (in /home/fabri/test/testHarness/RcppTestHarness/program) ==29579== ==29579== LEAK SUMMARY: ==29579== definitely lost: 23,536 bytes in 5,884 blocks ==29579== indirectly lost: 0 bytes in 0 blocks ==29579== possibly lost: 0 bytes in 0 blocks ==29579== still reachable: 8 bytes in 1 blocks ==29579== suppressed: 0 bytes in 0 blocks ==29579== Reachable blocks (those to which a pointer was found) are not shown. ==29579== To see them, rerun with: --leak-check=full --show-leak-kinds=all ==29579== ==29579== For lists of detected and suppressed errors, rerun with: -s ==29579== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) . As you can see, the program allocates 11,735 integers, but frees only 5,850 of them. Valgrind tells us that the error is due to the malloc call in the program at line 10: . ==29579== at 0x4845888: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==29579== by 0x11B414: copyAndFreeVector(int) (program.cpp:10) . Let’s solve the problem and run fuzz testing again. . #include &lt;deepstate/DeepState.hpp&gt; #include &lt;Rcpp.h&gt; #include &quot;RcppDeepState.h&quot; using namespace deepstate; // [[Rcpp::export]] void copyAndFreeVector(int source){ // allocates some space for 1 integer int* sample = (int*) malloc(sizeof(int)); free(sample); } TEST(IntAllocation, AllocateIntegerWithoutFree) { int v = RcppDeepState_int(0, 1000); copyAndFreeVector(v); } . With the exception of the 8 bytes classified as stil reachable, we don’t have any memory leaks this time. I discovered that these 8 bytes are related to the inclusion of the R library (-lR argument). . ==29423== Memcheck, a memory error detector ==29423== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al. ==29423== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info ==29423== Command: ./program --fuzz --timeout=1 ==29423== INFO: Starting fuzzing WARNING: No seed provided; using 1653991674 WARNING: No test specified, defaulting to first test defined (IntAllocation_AllocateIntegerWithoutFree) INFO: Done fuzzing! Ran 6335 tests (6335 tests/second) with 0 failed/6335 passed/0 abandoned tests ==29423== ==29423== HEAP SUMMARY: ==29423== in use at exit: 8 bytes in 1 blocks ==29423== total heap usage: 6,359 allocs, 6,358 frees, 144,452 bytes allocated ==29423== ==29423== LEAK SUMMARY: ==29423== definitely lost: 0 bytes in 0 blocks ==29423== indirectly lost: 0 bytes in 0 blocks ==29423== possibly lost: 0 bytes in 0 blocks ==29423== still reachable: 8 bytes in 1 blocks ==29423== suppressed: 0 bytes in 0 blocks ==29423== Reachable blocks (those to which a pointer was found) are not shown. ==29423== To see them, rerun with: --leak-check=full --show-leak-kinds=all ==29423== ==29423== For lists of detected and suppressed errors, rerun with: -s ==29423== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) . Conclusion . In this post we have seen how to use RcppDeepState auxiliary functions to manually generate a Test Harness. This is a procedure that is always done in an automated way by using deepstate_harness_create(). The purpose of this post is to understand how the Test Harness creation procedure works and combine RcppDeepState with a simple Rcpp program. . Rcpp package on CRAN &#8617; . | Akhila Chowdary blog &#8617; . | DeepState symbols definition &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/rcppdeepstate/2022/05/31/rcppdeepstate-introduction.html",
            "relUrl": "/rcppdeepstate/2022/05/31/rcppdeepstate-introduction.html",
            "date": " • May 31, 2022"
        }
        
    
  
    
        ,"post23": {
            "title": "Advanced fuzz testing with DeepState and Valgrind",
            "content": "Advanced fuzz testing . In the previous posts we have seen how to use DeepState to find simple errors in programs. The problem of the basic fuzz testing approach is that it does not allow us to detect more subtle issues, such as memory faults. In this article we introduce and explain a more advanced fuzz testing approach using the Valgrind memcheck tool and DeepState . Valgrind introduction . Valgrind is a debugging and profiling tool for Linux applications. The Valgrind distribution comes with a set of useful tools: a thread error detector (Helgrind), a cache profiler (Cachegrind), a heap profiler(Massif), a memory problem analyzer (Memcheck), and other tools are included in the Valgrind suite 1. For our purpose and interest we will focus uniquely on the Memcheck tool. This tool allows you to do an advanced memory analysis to identify two types of memory errors: . Memory leaks | Memory errors | . The first is related to missed frees: a software allocates memory in the heap dynamically and then forgets to free it. The latter is caused by more subtle errors, such as reading or writing from uninitialized memory locations: a program writes some bytes in a memory location that has not been initialized. Valgrind has a module called Memcheck that can help you find these kinds of issues. . Usage . With some simple steps we can perform an advanced memory analysis over a compiled binary. Before the analysis can take place, in order to have as much information as possible from the analysis results such as the error line number, it’s convenient to compile the program by passing the -g parameter to the g++ compiler. This option will produce more debugging information that will be included in the resulting binary. . Sample usage . The following is a description of the analysis procedure for a basic C++ program that allocates but does not release memory bytes. The program is reported in the following code snippet. As you can see the malloc invocation isn’t followed by a free, thus what we are expecting from Valgrind is a warning from the Memcheck tool about the missing free. . #include &lt;cstdlib&gt; int main(int argc, char** argv){ // allocates some space for 5 integers int* sample = (int*) malloc(sizeof(int) * 5); return 0; } . As previously noted, the program should be constructed using the -g argument to provide greater information about any mistakes that may occur during the analysis. Another useful option is --leak-check=full which performs a full analysis for memory leak problems at the end of the execution. . g++ -o program -g program.cpp . Now it is possible to run Valgrind by specifying the tool to use with the --tool parameter . valgrind --tool=memcheck ./program . The result for this analysis will look similar to the followng one . ==108488== Memcheck, a memory error detector ==108488== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al. ==108488== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info ==108488== Command: ./program ==108488== ==108488== ==108488== HEAP SUMMARY: ==108488== in use at exit: 20 bytes in 1 blocks ==108488== total heap usage: 2 allocs, 1 frees, 72,724 bytes allocated ==108488== ==108488== 20 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==108488== at 0x4845888: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==108488== by 0x109151: main (program.cpp:5) ==108488== ==108488== LEAK SUMMARY: ==108488== definitely lost: 20 bytes in 1 blocks ==108488== indirectly lost: 0 bytes in 0 blocks ==108488== possibly lost: 0 bytes in 0 blocks ==108488== still reachable: 0 bytes in 0 blocks ==108488== suppressed: 0 bytes in 0 blocks ==108488== ==108488== For lists of detected and suppressed errors, rerun with: -s ==108488== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) . The error summary shows that there is an error, in particular if we look at the leak summary we can see that 20 bytes are lost. So the question seems quite straightforward but, where does these 20 bytes come from? If we read carefully the valgrind description the error is found in the main function of our code at line 5 as stated by the following message . ==108488== by 0x109151: main (program.cpp:5) . The error in fact comes from the call to the malloc function that allocates 5 * sizeof(int) = 5 * 4 bytes = 20 contiguous bytes in heap but doesn’t free them. Note that the size of an integer is compiler and architecture dependent: in my case the size of a single int in memory is 4 bytes. . DeepState and Valgrind . Let’s take a closer look at how Valgrind may be used in conjunction with the fuzzing approaches described in my earlier postings. As previously stated, basic fuzz testing is restricted in its ability to detect just certain types of programming problems. Consider combining the power of Valgrind memory checks with the benefits of fuzz testing. That is precisely what we will explore in this section. . Fuzz testing programs to find memory safety errors using Valgrind and DeepState allows to increase the probability of finding subtle errors. . Use case example . Assume you’re writing a function that accepts a pointer to the beginning of a string, copies it into a new heap-allocated string, and then frees it. Consider that while developing this function, the developer forgot about the size of the source string. A careful reader would have caught the mistake and addressed the problem, however we want to understand how Valgrind with the auxiliary of DeepState could quickly find the problem. As you may have seen, the issue is caused by two factors: . the contiguous memory area pointed by newStr can contain a string of at most 20 characters; | the memcpy function doesn’t check for any terminating null character. | . This means that if someone passes as input parameter a string longer than 20 character, an heap overflow occur 2. . #include &lt;cstdlib&gt; #include &lt;cstring&gt; void copyAndFreeString(char* source){ // allocates some space for 20 characters char* newStr = (char*) malloc(sizeof(char) * 20); memcpy(newStr, source, strlen(source)); free(newStr); } int main(int argc, char** argv){ copyAndFreeString(argv[1]); return 0; } . Test with Valgrind . Now let’s consider to use Valgrind to check for any memory issue in the above program. The developer can try a lot of different options, forgetting about the border case(string greater than 20). . valgrind ./program 12345678 valgrind ./program hello world valgrind ./program test ... . The result for all this test looks similar to the following for the first command execution. . ==9019== Memcheck, a memory error detector ==9019== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al. ==9019== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info ==9019== Command: ./program 12345678 ==9019== ==9019== ==9019== HEAP SUMMARY: ==9019== in use at exit: 0 bytes in 0 blocks ==9019== total heap usage: 2 allocs, 2 frees, 72,724 bytes allocated ==9019== ==9019== All heap blocks were freed -- no leaks are possible ==9019== ==9019== For lists of detected and suppressed errors, rerun with: -s ==9019== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) . As you can see, it seems like everything is working fine, no error, no leak. However the developer missed to execute the border case. What we can learn here is that the greater the number of executions with varied inputs, the greater the chance of discovering subtle errors. . Test with Valgrind and DeepState . Let’s integrate DeepState with the previous code fragment. First of all we remove the main function and we create a TEST function. This is the Test Harness creation phase, discussed in the previous posts3. . #include &lt;cstdlib&gt; #include &lt;cstring&gt; void copyAndFreeString(char* source){ // allocates some space for 20 characters char* newStr = (char*) malloc(sizeof(char) * 20); memcpy(newStr, source, strlen(source)); free(newStr); } TEST(StringCopy, CopyAndFreeString) { char* str = DeepState_CStrUpToLen(30, &quot;abcdefABCDEF&quot;); ASSUME_GT(strlen(str), 1); copyAndFreeString(str); } . As you can see the same standard structure is used to define a test function with the TEST macro: we start by providing some symbolic variables, then the pre conditions and finally the post conditions. The post conditions aren’t useful in this situation because we’re simply looking for memory related issues. . The compilation process can be started with the following command after specifying the compiler to include the headers for DeepState and to include debugging information in the final binary . g++ -ldeepstate -o program -g program.cpp . This time instead of running Valgrind and DeepState separated we can run them together to achieve the maximum performance . valgrind --tool=memcheck ./program --fuzz --timeout=1 . ==16724== Memcheck, a memory error detector ==16724== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al. ==16724== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info ==16724== Command: ./program --fuzz --timeout=1 ==16724== INFO: Starting fuzzing WARNING: No seed provided; using 1653599264 WARNING: No test specified, defaulting to first test defined (StringCopy_CopyAndFreeString) ==16724== Invalid write of size 8 ==16724== at 0x484FA11: memmove (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==16724== by 0x114D25: copyAndFreeString(char*) (program.cpp:11) ==16724== by 0x114E6B: DeepState_Test_StringCopy_CopyAndFreeString() (program.cpp:26) ==16724== by 0x114D3D: DeepState_Run_StringCopy_CopyAndFreeString() (program.cpp:23) ==16724== by 0x10FD10: DeepState_RunTestNoFork (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== by 0x110234: DeepState_FuzzOneTestCase (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== by 0x1104C7: DeepState_Fuzz (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== by 0x10B98A: main (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== Address 0x4df6cf0 is 16 bytes inside a block of size 20 alloc&#39;d ==16724== at 0x4845888: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==16724== by 0x114CFF: copyAndFreeString(char*) (program.cpp:9) ==16724== by 0x114E6B: DeepState_Test_StringCopy_CopyAndFreeString() (program.cpp:26) ==16724== by 0x114D3D: DeepState_Run_StringCopy_CopyAndFreeString() (program.cpp:23) ==16724== by 0x10FD10: DeepState_RunTestNoFork (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== by 0x110234: DeepState_FuzzOneTestCase (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== by 0x1104C7: DeepState_Fuzz (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== by 0x10B98A: main (in /home/fabri/test/testHarness/TestHarnessSample/program) ... truncated file ... INFO: Done fuzzing! Ran 1 tests (1 tests/second) with 0 failed/1 passed/0 abandoned tests ==16724== ==16724== HEAP SUMMARY: ==16724== in use at exit: 0 bytes in 0 blocks ==16724== total heap usage: 3 allocs, 3 frees, 72,754 bytes allocated ==16724== ==16724== All heap blocks were freed -- no leaks are possible ==16724== ==16724== For lists of detected and suppressed errors, rerun with: -s ==16724== ERROR SUMMARY: 6 errors from 3 contexts (suppressed: 0 from 0) . This time the results are quite different: Valgrind with the auxiliary of DeepState was able to discover 6 errors from 3 different contexts. As we can see from the analysis of Valgrind (I have truncated the analysis to only the first error) the error is caused by the memmove invocated by memcpy in the program ad line 11. . Conclusion . Using only one tool is not always the best approach to find subtle programming errors. In fact in this article we discussed a advanced technique to perform a more sophisticated analysis. By combining fuzz testing from DeepState with memory analysis from Valgrind we were able to address more errors than the one we could have discovered by using a single technique. . Valgrind tools &#8617; . | Heap overflow &#8617; . | Test Harness creation guide &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/deepstate/valgrind/2022/05/27/advanced-deepstate.html",
            "relUrl": "/deepstate/valgrind/2022/05/27/advanced-deepstate.html",
            "date": " • May 27, 2022"
        }
        
    
  
    
        ,"post24": {
            "title": "DeepState introduction",
            "content": "DeepState Introduction . DeepState is a framework which provides developers the possibility to perform symbolic unit testing on some particular C++ functions by writing test harnesses. For writing a test harness, Deepstate follows a similar approch to the one of Google tests 1. The common problem between most of the symbolic unit testing libraries is that you as developer have to know how to use other binary analysis tools. With Deepstate this problem is solved by provinding a common interface the test harness creation process. . Installation . The installation process is quite simple, you just need to follow the istruction provided in the Readme file in the Deepstate repository on GitHub 2. In my case after the installation of all the necessary dependencies, I downloaded the repository snapshot using the standard git clone approach . git clone https://github.com/trailofbits/deepstate.git . and then started the compilation process with the auxiliary of Make tools . mkdir deepstate/build &amp;&amp; cd deepstate/build cmake ../ make . If the compilation process succeed the next step is the installation of the compiled files in the proper location in the host system: . sudo make install . Test Harness creation . Testing C++ code is not a straightforward task and it need to be accomplished in the correct way, otherwise it will lead to a failure both in the test and also in the source code. A Test Harness is a collection of software that allows to test a particular program by executing under some conditions. . The first step in test harness creation is to include the library and optionally set the namespace, in order to use all the functionalities provided by DeepState : . #include &lt;deepstate/DeepState.hpp&gt; using namespace deepstate; . A Test Harness definition in DeepState starts with the TEST macro. This macro takes two arguments as input: . a unit name | a test name | . The body of the function that starts with TEST will contain the following parts: . symbols definition | pre-conditions | post-conditions | . Let’s dive into this three main parts of a Test Harness creation procedure. . Symbols definition . The first part consists in the definition of the symbols that will be used as input for the function we need to test. The main goal for this task is to have a set of variables that will be filled by the DeepState with some non-deterministic data. . Symbolic execution tools and fuzzers needs to know which variable is symbolic in order to control them. Symbols definitions for basic data types (int, char, ..) are defined by concatenating the data type name with the symbolic_ prefix (symbolic_int, symbolic_char, ..). . DeepState provides us some useful functions to initialize our symbols with random data: . int DeepState_IntInRange(int low, int high) : initializes the symbol with an integer in the range low-high | float DeepState_FloatInRange(float low, float high) : initializes the symbol with a float number in the range low-high | double DeepState_DoubleInRange(double low, double high) : initializes the symbol with a double number in the range low-high | char* DeepState_CStr_C(size_t len, const char* allowed) : initializes a character array (a string) of length len with a set of allowed character taken from the character array `allowed | char* DeepState_CStrUpToLen(size_t maxLen, const char* allowed) : initializes a character array (a string) of length up to len with a set of allowed character taken from the character array allowed | . Pre conditions . Sometimes there is the necessity to constraint a little bit more the symbolic variables defined previously. This means that you have some particular constraint that your symbolic variable need to comply with, before running into the tests. All the tests that do not pass the pre conditions will be considered abandoned. . Pre conditions are defined using the ASSUME macro and also by the following more specialized ones: . ASSUME_EQ : checks for the equality of the 2 parameters (operator ==) | ASSUME_NE : checks if the 2 parameters are not equal (operator !=) | ASSUME_LT : checks if the first parameter is less than the second (operator &lt;) | ASSUME_LE : checks if the first parameter is less or equal to the second (operator &lt;=) | ASSUME_GT : checks if the first parameter is greater than the second (operator &gt;) | ASSUME_GE : checks if the first parameter is greater or equal to the second (operator &gt;=) | . Example . Suppose you have to pass to your test only strings with a minimum length of 5 characters and up to 10 characters (both inclusive). This types of strings can not be created by only using DeepState_CStrUpToLen. We have to constraint the fact that the length of the string should also be greater then 5. This may be accomplished by using a precondition that checks if the created string meets the requirement that its length be larger than or equal to 5. With the preceding list in mind, this can be implemented with the ASSUME_GE macro in the following way: . TEST(UnitName, TestName) { char* str = DeepState_CStrUpToLen(50, &quot;abcdefABCDEF&quot;); ASSUME_GE(strlen(str), 5); ... } . Post conditions . The last part is the check of the execution result of a test. This can be done with post conditions that checks if the results satisfy some constraints. Similar to the pre conditions, the post condition defines a list of macros that help us to perform this checks. This time a post condition is defined using the ASSERT macro and all it’s specialized versions (ASSERT_EQ, ASSERT_NE, ASSERT_FALSE, …). . Example . Assume that we want to test a function that compress a string as input into a fixed length string : an hash function like MD5. A possible post condition will check if the hashed string is of a certain length (in the case of md5, exactly 32 characters). . TEST(UnitName, TestName) { char* str = DeepState_CStrUpToLen(50, &quot;abcdefABCDEF&quot;); // Pre conditions ASSUME_GE(strlen(str), 5); // execution char* hashedString = md5(str); // post conditions ASSERT_EQ(strlen(hashedString), 32); } . Test harness compilation . You can compile the test harness using a standard C++ compiler like g++ by specifying the linker to include the deepstate header with the -ldeepstate parameter . g++ -ldeepstate -o harness harness.cpp . The output of this procedure is a compiled harness file that can be executed. . Fuzz test execution . The compiled test harness can be executed using some analysis tools like manticore, angr or valgrind to discover memory leaks in the code. You can also run it in a standalone mode by executing it directly in the console with the --fuzz option. This last option enables DeepState to perform brute force fuzzing. Another useful option is --timeout that allows to specify a timeout(in seconds) after which the fuzzing procedure will be stopped. In addition with the --input_which_test you can specify the test to execute in the format UnitName_TestName. . ./harness --fuzz --timeout=5 --input_which_test UnitName_TestName . This execution will give us the total number of failed, passed and abandoned tests . Advanced fuzz testing . I’ll go through how to use DeepState in conjunction with more complex tools like Valgrind in the next blog posts. . https://google.github.io/googletest/ &#8617; . | https://github.com/trailofbits/deepstate#buildnrun &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/deepstate/2022/05/25/about-deepstate.html",
            "relUrl": "/deepstate/2022/05/25/about-deepstate.html",
            "date": " • May 25, 2022"
        }
        
    
  
    
        ,"post25": {
            "title": "Sample DeepState fuzz test",
            "content": "Sample usage of the Deepstate C++ library . Assume that the NASA FPrime library contains a function that converts a string to a Mixed-Uppercase string. In reality the NASA FPrime contains a lot of functions that deals with strings. What is a Mixed-Uppercase string? With this term I am referring to a string which all characters in odd positions must be capitalized. The following is a very simple function that computes this task: . char* mixedUppercase(char* source){ for( int i=0; i&lt; strlen(source); i+=2 ){ // check if the character at the ith position is lowercase, otherwise skip if (*(source + i) &gt;= 97 &amp;&amp; *(source + i) &lt;= 122){ *(source + i) -= 32; } } return source; } . This function takes a character array as input and performs the odd-uppercase replacement in place. This function returns the pointer to the first character of the original char vector. . Test harness creation . First of all I’ll start writing the TestHarness after I’ve determined what the expectations are for this function. First, I’ll include the DeepState library’s required header files: . #include &lt;deepstate/DeepState.hpp&gt; . Then, using the TEST macro, I’ll begin constructing the test function, taking into account the expected outcome from the mixedUppercase function. The following code sample illustrates one possible implementation: . TEST(MixedUppercase, OnlyGeneratedMixedUppercase) { char* str = DeepState_CStrUpToLen(50, &quot;abcdefABCDEF&quot;); ASSUME_GT(strlen(str), 1); mixedUppercase(str); ASSERT_TRUE(isMixedUppercase(str)) &lt;&lt; str &lt;&lt; &quot; is not a mixed uppercase string&quot;; } . This test function creates a string with a length of up to 50 characters, containing characters from the set &quot;abcdefABCDEF&quot;. After that we make the assumption that the the strings that are relevant for the test are the one of a length greter than 1. Finally we execute our function and we check using the ASSERT_TRUE postcondition that the result is a Mixed-Uppercase string. . Where the isMixedUppercase function returns True if the string passed is a Mixed-Uppercase string, otherwise false. . bool isMixedUppercase(char* str){ bool res = true; for (int i=0; i&lt; strlen(str); i+=2){ res = res &amp;&amp; (*(str + i) &gt;= 65 &amp;&amp; *(str + i) &lt;= 90); } return res; } . Fuzz testing . Now that the Test harness is written, I can move on and perform some fuzz testing over the function. First I will compile the Test harness by specifying the linker to include the deepstate header with the -ldeepstate parameter . g++ -ldeepstate -o harness harness.cpp . Finally I run a non deterministic fuzz testing on the TestHarness by executing the compiled TestHarness with the following parameters . ./harness --fuzz --timeout=1 --input_which_test MixedUppercase_OnlyGeneratedMixedUppercase . Result . After the execution I can check the results. As expected, in my case no error was found. . INFO: Starting fuzzing WARNING: No seed provided; using 1652815282 INFO: Done fuzzing! Ran 18918 tests (18918 tests/second) with 0 failed/17447 passed/1471 abandoned tests .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/deepstate/2022/05/17/deepstate-sample.html",
            "relUrl": "/deepstate/2022/05/17/deepstate-sample.html",
            "date": " • May 17, 2022"
        }
        
    
  

  
  

  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://fabriziosandri.github.io/gsoc-2022-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}