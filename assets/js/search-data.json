{
  
    
        "post0": {
            "title": "First changes to RcppDeepState",
            "content": "Introduction . This post is meant to be a reference for the work I’ve done in the Community Bonding Period and the first coding period’s first week. . Weeks 1-3 (Community Bonding Period) . I spent this three weeks of Community Bonding Period interacting with my mentors, familiarizing myself with the tools and working on high priority tasks. . Using this blog as a way to familiarize myself with the tools, I started working with DeepState, showing some basic examples and moving step by step with more complex one. Then I gave a brief introduction to Valgrind and showed how it might be used in conjunction with DeepState to produce a sophisticated fuzz testing toolbox. When these three powerful tools —Valgrind, DeepState, and Rcpp— were integrated, I introduced Rcpp and finally RcppDeepState. . Reference . Blog posts: . Sample DeepState fuzz test | DeepState introduction | Advanced fuzz testing with DeepState and Valgrind | Introduction to RcppDeepState | Rcpp package fuzz testing with RcppDeepState | . Pull requests: . Makefile generation fix and improvements | Override default Makevars | Harness creation improvements | . Issues: . Segmentation fault not catched | Fuzzing functions with Rcpp parameters | . External issues: . Unexpected Segmentation Fault | . Week 4 . I have spent the most of this first week focusing on some important tasks that I discovered during the Community Bonding Period. Everything specifically began when I discovered that debug symbols were not present by default on some systems. This led to the creation of the Makevars file inside the src directory of each package, before R CMD INSTALL is run. Based on this I created a custom workflow to check if debug symbols are included by default or not on the system. I discovered several bugs in the RcppDeepState library while developing this workflow and was able to effectively fix them. . A detailed description of the changes and problems I encountered in this first week can be found in pull request #6. I report some of them here: . solved the problem that on some platforms debug symbols are not included by default; | solved some problems with RInside. In detail I moved the definition of RInside outside of the TEST function in order to preserve the seeds and to avoid the R is already initialized error; | implemented the possibility to add a seed argument to the deepstate_harness_compile_run function; | solved the problem of the Segmentation fault that prevented DeepState to create the output files; | Reference . Blog posts: . Debugging Rcpp outside of R | Deterministic fuzz testing with DeepState and Rcpp | . Pull requests: . Debug symbols tests | . Issues: . Valgrind for initial pass | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/summary/2022/06/24/first-week.html",
            "relUrl": "/summary/2022/06/24/first-week.html",
            "date": " • Jun 24, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Deterministic fuzz testing with DeepState and Rcpp",
            "content": "Motivation . While searching for a way to perform non deterministic fuzz testing (using some kind of seeds) to be used in the workflow for the pull request #6, I discovered that the seed would not work if the RInside declaration is made inside the TEST macro of the test Harness. Let’s have a look at an example. . Example . Recall to the example of the previous post, where we wanted to perform fuzz testing on a simple Rcpp function that takes an integer vector as input and returns the first element. Let’s say we want to discover a seed that will allow us to replicate the DeepState inputs throughout several executions, in a way that the execution will be deterministic. Let’s add a cout at line 36 in order to observe the inputs generated by DeepState. . #include &lt;iostream&gt; #include &lt;Rcpp.h&gt; #include &lt;RInside.h&gt; #include &lt;deepstate/DeepState.hpp&gt; using namespace deepstate; // [[Rcpp::export]] int getFirstElement(Rcpp::IntegerVector v) { if (v.size() != 0){ return v[0]; } return -1; } // random IntegerVector generation procedure Rcpp::IntegerVector randomIntegerVector(int maxSize){ int size = DeepState_IntInRange(1,maxSize); Rcpp::IntegerVector vec(size); for (int i=0; i&lt;size; i++){ vec[i] = DeepState_IntInRange(0,1000); } return vec; } TEST(Unit, name){ static RInside R; Rcpp::IntegerVector randomVec = randomIntegerVector(20); std::cout &lt;&lt; randomVec &lt;&lt; std::endl; getFirstElement(randomVec); } . The result will change across several executions regardless of whether this harness is executed using the --seed=1 argument. The first ten lines of output from two distinct runs are shown below, and it appears that the seed option has no influence on the produced input. . $ ./getFirstElement --fuzz --timeout=1 --seed=1 | head INFO: Starting fuzzing WARNING: No test specified, defaulting to first test defined (Unit_name) 808 622 869 877 455 672 774 844 240 910 915 474 182 907 28 1000 921 295 168 356 675 825 344 511 36 735 784 573 715 622 338 351 542 750 202 746 817 227 9 588 973 14 4 194 627 987 249 578 315 275 415 918 1 777 966 69 806 69 559 978 421 300 867 214 429 872 755 856 345 993 722 942 378 593 210 780 393 760 430 106 400 846 144 767 669 263 278 872 625 265 58 203 89 832 969 144 952 266 192 975 327 386 816 946 35 $ ./getFirstElement --fuzz --timeout=1 --seed=1 | head INFO: Starting fuzzing WARNING: No test specified, defaulting to first test defined (Unit_name) 657 470 974 648 599 658 812 515 388 162 698 87 20 672 429 355 22 104 1000 742 779 948 157 630 840 336 616 666 220 185 76 965 220 18 531 484 232 85 76 959 388 473 630 390 997 619 474 386 449 650 255 520 717 909 775 783 249 75 988 668 422 595 767 182 417 60 691 783 972 996 740 220 732 19 390 253 704 89 329 815 520 122 600 111 27 796 541 591 778 352 673 205 195 526 73 318 380 155 221 972 540 668 985 462 953 175 . Solution . This peculiar behavior, I discovered, is caused by the RInside statement within the TEST macro. The seed will work if the above program is modified by shifting the RInside declaration to the beginning and deleting the static keyword. . #include &lt;iostream&gt; #include &lt;Rcpp.h&gt; #include &lt;RInside.h&gt; #include &lt;deepstate/DeepState.hpp&gt; using namespace deepstate; RInside Rinstance; // [[Rcpp::export]] int getFirstElement(Rcpp::IntegerVector v) { if (v.size() != 0){ return v[0]; } return -1; } // random IntegerVector generation procedure Rcpp::IntegerVector randomIntegerVector(int maxSize){ int size = DeepState_IntInRange(1,maxSize); Rcpp::IntegerVector vec(size); for (int i=0; i&lt;size; i++){ vec[i] = DeepState_IntInRange(0,1000); } return vec; } TEST(Unit, name){ Rcpp::IntegerVector randomVec = randomIntegerVector(20); std::cout &lt;&lt; randomVec &lt;&lt; std::endl; getFirstElement(randomVec); } . The output will now remain the same over multiple executions . $ ./getFirstElement --fuzz --timeout=1 --seed=1 | head INFO: Starting fuzzing WARNING: No test specified, defaulting to first test defined (Unit_name) 45 876 469 501 681 966 606 500 505 917 974 278 278 134 30 89 629 63 662 549 902 171 509 314 370 622 287 508 904 960 320 971 431 402 436 155 610 425 643 826 670 136 877 558 789 66 681 315 4 29 888 577 658 499 191 348 959 539 740 712 152 704 460 449 727 889 811 54 456 168 891 196 561 467 544 254 942 911 256 663 578 517 845 159 167 671 342 887 546 605 607 354 881 361 545 865 588 312 649 123 750 729 474 863 43 482 $ ./getFirstElement --fuzz --timeout=1 --seed=1 | head INFO: Starting fuzzing WARNING: No test specified, defaulting to first test defined (Unit_name) 45 876 469 501 681 966 606 500 505 917 974 278 278 134 30 89 629 63 662 549 902 171 509 314 370 622 287 508 904 960 320 971 431 402 436 155 610 425 643 826 670 136 877 558 789 66 681 315 4 29 888 577 658 499 191 348 959 539 740 712 152 704 460 449 727 889 811 54 456 168 891 196 561 467 544 254 942 911 256 663 578 517 845 159 167 671 342 887 546 605 607 354 881 361 545 865 588 312 649 123 750 729 474 863 43 482 . This problem is resolved in the pull request #6. .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/deepstate/rcpp/c++/r/2022/06/21/deterministic-fuzz-testing.html",
            "relUrl": "/deepstate/rcpp/c++/r/2022/06/21/deterministic-fuzz-testing.html",
            "date": " • Jun 21, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Debugging Rcpp outside of R",
            "content": "Introduction . Sometimes it could be necessary to test your Rcpp defined code using an external tool, like Valgrind or GDB. This process however will almost likely come to a crash of your program with a strange Segmentation Fault error. The error is due to the fact that executing Rcpp code is only possible within a working R environment. I talked about this with a Rcpp community member and his answer is reported in this issue #1221. . “All” that Rcpp does is to provide R with callable code via the .Call() interface which is meant to extend a running R session. Nowhere in the R (or Rcpp) documentation is it hinted that you can run code separately. Which is why we run all tests etc from R. . So, the question might appear straightforward, but is it feasible to run Rcpp code outside of a R environment? Using RInside, the answer is yes. . Proof of concept . Imagine you have the following bootstrap function and want to simply execute it and get the result, that you expect to be 10. . #include &lt;iostream&gt; #include &lt;Rcpp.h&gt; // [[Rcpp::export]] int bootstrap() { // Allocate a sample NumericVector Rcpp::NumericVector sample {10,20,30,40,50}; return sample[0]; } int main(int argc, char* argv[]){ std::cout &lt;&lt; bootstrap() std::endl; return 0; } . If you try to compile and execute this program however the result is quite different: . $ g++ -lR -I&quot;/usr/include/R/&quot; -I/usr/local/include -I&quot;/home/fabri/R/x86_64-pc-linux-gnu-library/4.2/Rcpp/include&quot; -L/usr/lib64/R/lib -o bootstrap bootstrap.cpp $ ./bootstrap [1] 23848 segmentation fault (core dumped) ./bootstrap . Solution . The solution is to embed in your code a working R environment within the process. This can be done using the powerful RInside library. All you have to do is to include the header files and create an embedded R instance. The preceding example will be modified as follows: . #include &lt;iostream&gt; #include &lt;Rcpp.h&gt; #include &lt;RInside.h&gt; // [[Rcpp::export]] int bootstrap() { RInside R; // Allocate a sample NumericVector Rcpp::NumericVector sample {10,20,30,40,50}; return sample[0]; } int main(int argc, char* argv[]){ std::cout &lt;&lt; bootstrap() std::endl; return 0; } . There will be no errors if you try to compile and run the program after this update. . $ g++ -g -lR -lRInside -I&quot;/usr/include/R/&quot; -I/usr/local/include -I/usr/lib/R/library/RInside/include -I&quot;/home/fabri/R/x86_64-pc-linux-gnu-library/4.2/Rcpp/include&quot; -L/usr/lib/R/library/RInside/lib -Wl,-rpath=/usr/lib/R/library/RInside/lib -L/usr/lib64/R/lib -o bootstrap bootstrap.cpp $ ./bootstrap 10 . Debugging with Deepstate and valgrind . Now that we have all of the necessary tools, we can start developing our first Rcpp function test harness. Imagine that we want to fuzz test a function named getFirstElement that returns the first element of an Rcpp IntegerVector. Deepstate might be used to send some randomly initialized vectors to this method in order to discover any memory issues. To do this, we may create a basic test harness that employs a function that produces a random integer vector, in this instance randomIntegerVector, and then passes that vector to the getFirstElement function. This is the final result. . #include &lt;iostream&gt; #include &lt;Rcpp.h&gt; #include &lt;RInside.h&gt; #include &lt;deepstate/DeepState.hpp&gt; using namespace deepstate; // [[Rcpp::export]] int getFirstElement(Rcpp::IntegerVector v) { if (v.size() != 0){ return v[0]; } return -1; } // random IntegerVector generation procedure Rcpp::IntegerVector randomIntegerVector(int maxSize){ int size = DeepState_IntInRange(1,maxSize); Rcpp::IntegerVector vec(size); for (int i=0; i&lt;size; i++){ vec[i] = DeepState_IntInRange(0,1000); } return vec; } TEST(Unit, name){ static RInside R; Rcpp::IntegerVector randomVec = randomIntegerVector(20); getFirstElement(randomVec); } . It’s worth noting that the RInside instance has been defined as static, this will prevent error such as R is already initialized. Making the R variable static force the application to use the same RInside object for all of the application’s lifetime. . Let’s now compile the harness and run it with the Valgrind Memcheck tool . $ g++ -g -ldeepstate -lR -lRInside -I&quot;/usr/include/R/&quot; -I/usr/local/include -I/usr/lib/R/library/RInside/include -I&quot;/home/fabri/R/x86_64-pc-linux-gnu-library/4.2/Rcpp/include&quot; -L/usr/lib/R/library/RInside/lib -Wl,-rpath=/usr/lib/R/library/RInside/lib -L/usr/lib64/R/lib -o getFirstElement getFirstElement.cpp $ valgrind ./getFirstElement --fuzz --timeout=10 . This will be the result . ==43210== Memcheck, a memory error detector ==43210== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al. ==43210== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info ==43210== Command: ./getFirstElement --fuzz --timeout=10 ==43210== INFO: Starting fuzzing WARNING: No seed provided; using 1654880923 WARNING: No test specified, defaulting to first test defined (Unit_name) INFO: Done fuzzing! Ran 1828 tests (182 tests/second) with 0 failed/1828 passed/0 abandoned tests ==43210== ==43210== HEAP SUMMARY: ==43210== in use at exit: 51,299,862 bytes in 9,936 blocks ==43210== total heap usage: 30,813 allocs, 20,877 frees, 87,993,209 bytes allocated ==43210== ==43210== LEAK SUMMARY: ==43210== definitely lost: 0 bytes in 0 blocks ==43210== indirectly lost: 0 bytes in 0 blocks ==43210== possibly lost: 0 bytes in 0 blocks ==43210== still reachable: 51,299,862 bytes in 9,936 blocks ==43210== of which reachable via heuristic: ==43210== newarray : 4,264 bytes in 1 blocks ==43210== suppressed: 0 bytes in 0 blocks ==43210== Rerun with --leak-check=full to see details of leaked memory ==43210== ==43210== For lists of detected and suppressed errors, rerun with: -s ==43210== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) . Conclusion . We were able to run a debugging tool, specifically the Valgrind suite’s Memcheck tool. This demonstrates how integrating many techniques may be an effective method of solving a problem. .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/rcpp/debug/r/c++/valgrind/2022/06/10/rcpp-debugging.html",
            "relUrl": "/rcpp/debug/r/c++/valgrind/2022/06/10/rcpp-debugging.html",
            "date": " • Jun 10, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Rcpp package fuzz testing with RcppDeepState",
            "content": "Automated fuzz testing . We saw how to manually create a Test Harness for a Rcpp written function in order to run fuzz testing on it in the previous blog article. In practice, this strategy is never used: the majority of the time, the Harness construction process is automated. This is what we’ll talk about in this blog article. . The steps . The RcppDeepState library was introduced in the previous post to do package fuzz testing. This library includes a collection of features that allow you to construct the test harness for a certain package function automatically. . RccpDeepState includes the following two key functions: . deepstate_harness_compile_run | deepstate_harness_analyze_pkg | . Let’s take a closer look at them. . The compilation procedure . The function deepstate_harness_compile_run(package_path) is used to run the compilation process, and it accepts the location of the library we want to fuzz test. . This step begins by looking for any Rcpp written functions in the supplied library. This is accomplished by looking for information about the package’s exported functions, which are found in the RcppExports.cpp file in the src source folder. Once you’ve gathered all of the data, you’ll need to construct a test harness file. This phase is done by deepstate_pkg_create, which generates a Harness file for each function discovered in &lt;package_dir&gt;/inst/testfiles/&lt;function_name&gt;. This file includes the headers as well as the ‘TEST’ function definition, which includes all of the symbolic variables. . Using the R CMD INSTALL command, a shared object for the library is also produced (.so file). It’s worth noting that the shared object must be compiled with the -g option in order to include debug symbols. I discovered that the shared object was produced without debugging symbols on some Linux systems. I wrote an additional piece of code to rewrite the Makevars file holding the compilation parameters in order to solve the problem. This issue is solved in the Pull request #3. . The fuzz testing approach begins once the library and harness have been generated: the output of the tests is stored in order to evaluate them later using Valgrind. . The analysis phase . Following the completion of the fuzz testing, the next step is to analyze the inputs generated. This is done using deepstate_harness_analyze_pkg(package_path). This function looks for binary files containing the inputs in the &lt;package_dir&gt;/inst/testfiles directory. The harness is then rerun with the --input_test_file option: this allows to provide an input test case. It’s worth noting that in this second stage, the harness is examined by the Valgrind Memcheck tool, resulting in an XML log file. . RcppDeepState then parses this file for error information (message, line number, etc.) and returns them to the deepstate_harness_analyze_pkg(package_path) function. . Example . RcppDeepState includes a sample library under the RcppDeepState/inst/testpkgs/testSAN folder. It can be useful as a toy library for detecting problems. Following the approach outlined in the previous part, we examine the package in this section. . The first step is to use deepstate_harness_compile_run to compile the library. This function prints a list of successfully constructed harness when the compilation processes are done. In this example, all of the functions were appropriately built. On the other hand, if any functions are not built, an error message is generated. . &gt; deepstate_harness_compile_run(&quot;RcppDeepState/inst/testpkgs/testSAN&quot;) ... compilation steps ... [1] &quot;rcpp_read_out_of_bound&quot; &quot;rcpp_use_after_deallocate&quot; [3] &quot;rcpp_use_after_free&quot; &quot;rcpp_use_uninitialized&quot; [5] &quot;rcpp_write_index_outofbound&quot; &quot;rcpp_zero_sized_array&quot; . The next step is to use Valgrind’s Memcheck tool to perform the analysis. . &gt; result &lt;- deepstate_harness_analyze_pkg(&quot;RcppDeepState/inst/testpkgs/testSAN&quot;) . We may get a detailed description of the faults detected by printing the contents of result$logtable : . &gt; knitr::kable(result$logtable) |err.kind |message |file.line |address.msg |address.trace | |:--|:-|:-|:--|:-| |InvalidRead |Invalid read of size 1 |use_after_deallocate.cpp : 8 |Address 0x806cfe5 is 5 bytes after a block of size 0 free&#39;d |use_after_deallocate.cpp : 6 | |InvalidRead |Invalid read of size 1 |use_after_deallocate.cpp : 7 |Address 0x806cfe5 is 5 bytes after a block of size 0 free&#39;d |use_after_deallocate.cpp : 6 | |err.kind |message |file.line |address.msg |address.trace | |:--|:-|:-|:--|:-| |InvalidRead |Invalid read of size 1 |use_after_deallocate.cpp : 8 |Address 0x806cfe5 is 5 bytes after a block of size 0 free&#39;d |use_after_deallocate.cpp : 6 | |InvalidRead |Invalid read of size 1 |use_after_deallocate.cpp : 7 |Address 0x806cfe5 is 5 bytes after a block of size 0 free&#39;d |use_after_deallocate.cpp : 6 | |err.kind |message |file.line |address.msg |address.trace | |:--|:-|:-|:--|:-| |InvalidRead |Invalid read of size 1 |use_after_deallocate.cpp : 8 |Address 0x806cfe5 is 5 bytes after a block of size 0 free&#39;d |use_after_deallocate.cpp : 6 | |InvalidRead |Invalid read of size 1 |use_after_deallocate.cpp : 7 |Address 0x806cfe5 is 5 bytes after a block of size 0 free&#39;d |use_after_deallocate.cpp : 6 | .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/rcppdeepstate/fuzz/r/c++/2022/06/07/rcppdeepstate-automatic-fuzz-testing-copy.html",
            "relUrl": "/rcppdeepstate/fuzz/r/c++/2022/06/07/rcppdeepstate-automatic-fuzz-testing-copy.html",
            "date": " • Jun 7, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Introduction to RcppDeepState",
            "content": "Introduction to RcppDeepState . In previous posts, we’ve shown how to use DeepState in conjunction with Valgrind to create a tool that can detect more subtle programming errors in the code. In this post, we’ll introduce RcppDeepState, which will add another brick to this toolkit. . Rcpp . The Rcpp package1 gives R developers a way to write C++ code for some of its modules. It’s sometimes useful to write C++ code in place of R functions; it’s a performance trade-off. It has been demonstrated that R is particularly inefficient in computing recursive functions when compared to C++. . It’s not the purpose of this article to discuss the Rcpp library, however what you need to know in order to continue is that Rcpp allows to call some external C++ functions exported to the R environment by tagging them with the // [[Rcpp::export]] comment on top of them. . Installation . The installation of the library is quite a straightforward task since the package is available on CRAN. . install.packages(&quot;Rcpp&quot;) . Sample usage . Let’s look at a simple example of a Fibonacci recursive function written in C++ and exported to the R environment to have a better idea of how Rcpp works. Let’s start with a C++ definition of the Fibonacci function. . int fibonacci(int n) { if (n &lt;= 1) return 1; return fib(n-1) + fib(n-2); } . The first step to integrate this function with the R environment is to include the appropriate header of Rcpp with it’s associated namespace. The final step is to export the fibonacci function. As mentioned earlier to do this we use the // [[Rcpp::export]] comment. By doing this way, the R environment can easily understand which function should be exported. The final result should look somewhat like this: . #include &lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] int fibonacci(int n) { if (n &lt;= 1) return 1; return fibonacci(n-1) + fibonacci(n-2); } . We don’t need to compile anything in order for this function to work; all we have to do in our R environment is include the appropriate library and call the sourcCpp function. This function automatically compiles the C++ code and sources it into the running environment, in the same way the standard source function works. . &gt; require(&quot;Rcpp&quot;) &gt; sourceCpp(&quot;./fibonacci.cpp&quot;) &gt; fibonacci(5) [1] 8 . Rcpp based package . In the previous example we ran a single C++ file, however most of the times Rcpp is bundled inside packages. This allows users to use this packages without actually having any C++ development tool. To initialize a package using Rcpp, we use the Rcpp.package.skeleton function. If you want to generate a package based on the previous Rcpp fibonacci script, simply supply a list of C++ files to the skeleton function’s cpp_files parameter. . Rcpp.package.skeleton(&quot;Fibonacci&quot;, example_code = FALSE, cpp_files = c(&quot;fibonacci.cpp&quot;)) . This way we end up with a folder containing a working Rcpp based module: . Rcpp source file are located in src | R files are located in R | Rd documentation files are located in man | . RcppDeepState . Let’s get started with the main topic of this article: RcppDeepState. RcppDeepState is a combination of three different tools: Rcpp, DeepState, and Valgrind. RcppDeepState’s purpose is to perform fuzz testing on Rcpp-based modules. The related work is restricted to R-level fuzzing and does not include fuzz testing of compiled C++ code developed with Rcpp. The lack of such support for fuzz testing led Akhila Chowdary 2 to create such a powerful tool. . Installation process . Since RcppDeepState is not available on CRAN, it must be installed manually. We can use the traditional devtools way to download the package from the official repository and install it: . install.packages(&quot;devtools&quot;) require(&quot;devtools&quot;) devtools::install_github(&quot;akhikolla/RcppDeepState&quot;) . In alternative it’s possible to directly download the source and install the package from a working R environment: . install.packages(&quot;/path/to/RcppDeepState&quot;, repos = NULL, type=&quot;source&quot;) . Steps . In order to perform fuzz testing, RcppDeepState follows the same steps we have used in the previous posts, with a few more steps in between: . find the exported Rcpp functions | DeepState test harness creation | package analysis using Valgrind | . Some steps are left out, such as the automatic test harness creation. We will see this later on in another post. . RcppDeepState auxiliary functions . The objective of RcppDeepState is to create a link between Rcpp and DeepState in order to perform fuzz testing. This can be done by using some C++ auxiliary function that initializes all the necessary symbolic variables. Symbolic variables were already discussed in a previous article 3. . A list of common auxiliary functions is reported in the following list: . RcppDeepState_int(): generates an integer symbolic variable. Optionally, the parameters int low, int high can be used to restrict the generated numbers in a range | RcppDeepState_double(): generates a double symbolic variable. Optionally, the parameters double low, double high can be used to restrict the generated numbers in a range | RcppDeepState_IntegerVector: generates a vector of integers with a size in the range 0-100 (inclusive). Optionally, the parameters int size, int low, int high can be used to specify the vector size and to restrict the generated numbers in a range. | RcppDeepState_NumericVector(): generates a vector of doubles with a size in the range 0-100 (inclusive). Optionally, the parameters int size, int low, int high can be used to specify the vector size and to restrict the generated numbers in a range. | RcppDeepState_NumericMatrix(): generates a matrix of doubles with a size in the range (rows=0,cols=0) and (10,10). Optionally, the parameters int row,int column,int low,int high can be used to specify the matrix size (in terms of rows and cols) and to restrict the generated numbers in a range. | RcppDeepState_CharacterVector(): generates a vector of characters with a size in the range 0-100 (inclusive). | RcppDeepState_string(): generates a string of a length up to 26 characters taken from the alphabet. | . This functions can be used in the test harness TEST procedure. Let’s use an example to further understand this. . RcppDeepState TestHarness sample . RcppDeepState has an automated test harness generation function, deepstate_harness_create(). However, we manually create a TestHarness using the auxiliary functions indicated above in order to understand how RcppDeepState works behind the scenes. . Assume you have a leaked function that takes an integer as an input and allocates some Heap memory to it. Consider the case where the developer failed to free the used memory if the integer parameter is more than 500. Imagine that for some strange motivation the developer forgot to free the used memory if the integer parameter is greater than 500 for some strange reason. The following is an example of the function: . void copyAndFreeVector(int source){ // allocates some space for 1 integer int* sample = (int*) malloc(sizeof(int)); if (source &lt; 500){ free(sample); } } . A TestHarness can be generated for this program, using the auxiliary functions above. It can be simply done by creating a symbolic integer variable, initialized using the appropriate RcppDeepState_int(int low, int high) function. As you can see, in order to work with Rcpp and RcppDeepState you need to include the necessary libraries. . #include &lt;deepstate/DeepState.hpp&gt; #include &lt;Rcpp.h&gt; #include &lt;RcppDeepState.h&gt; using namespace deepstate; // [[Rcpp::export]] void copyAndFreeVector(int source){ // allocates some space for 1 integer int* sample = (int*) malloc(sizeof(int)); if (source &lt; 500){ free(sample); } } TEST(IntAllocation, AllocateIntegerWithoutFree) { int v = RcppDeepState_int(0, 1000); copyAndFreeVector(v); } . Now that the test harness is completed we can compile it, and run the fuzz testing with Valgrind. The compilation needs a lot of library and headers inclusion in order to properly work. We need to include the headers files for R, Rcpp, RcppDeepState and RcppArmadillo. In addition we need to specify to g++ where to find the shared objects (.so files) for R and RInside. The -g option is included to add more debugging information to the compiled binary, which is worth mentioning. . g++ -I/usr/include/R -I/usr/lib/R/library/Rcpp/include -I/usr/lib/R/library/RcppDeepState/include -I/usr/lib/R/library/RcppArmadillo/include -L/usr/lib64/R/lib -L/usr/lib/R/library/RInside/lib -lR -lRInside -ldeepstate -o program -g program.cpp . The last step is to run the compiled program using Valgrind with the --leak-check=full option in order to find memory leaks. . valgrind --leak-check=full ./program --fuzz --timeout=1 . This is the result . ==29579== Memcheck, a memory error detector ==29579== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al. ==29579== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info ==29579== Command: ./program --fuzz --timeout=1 ==29579== INFO: Starting fuzzing WARNING: No seed provided; using 1653991738 WARNING: No test specified, defaulting to first test defined (IntAllocation_AllocateIntegerWithoutFree) INFO: Done fuzzing! Ran 11711 tests (11711 tests/second) with 0 failed/11711 passed/0 abandoned tests ==29579== ==29579== HEAP SUMMARY: ==29579== in use at exit: 23,544 bytes in 5,885 blocks ==29579== total heap usage: 11,735 allocs, 5,850 frees, 165,956 bytes allocated ==29579== ==29579== 23,536 bytes in 5,884 blocks are definitely lost in loss record 2 of 2 ==29579== at 0x4845888: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==29579== by 0x11B414: copyAndFreeVector(int) (program.cpp:10) ==29579== by 0x11B484: DeepState_Test_IntAllocation_AllocateIntegerWithoutFree() (program.cpp:18) ==29579== by 0x11B439: DeepState_Run_IntAllocation_AllocateIntegerWithoutFree() (program.cpp:16) ==29579== by 0x113130: DeepState_RunTestNoFork (in /home/fabri/test/testHarness/RcppTestHarness/program) ==29579== by 0x113654: DeepState_FuzzOneTestCase (in /home/fabri/test/testHarness/RcppTestHarness/program) ==29579== by 0x1138E7: DeepState_Fuzz (in /home/fabri/test/testHarness/RcppTestHarness/program) ==29579== by 0x10EDAA: main (in /home/fabri/test/testHarness/RcppTestHarness/program) ==29579== ==29579== LEAK SUMMARY: ==29579== definitely lost: 23,536 bytes in 5,884 blocks ==29579== indirectly lost: 0 bytes in 0 blocks ==29579== possibly lost: 0 bytes in 0 blocks ==29579== still reachable: 8 bytes in 1 blocks ==29579== suppressed: 0 bytes in 0 blocks ==29579== Reachable blocks (those to which a pointer was found) are not shown. ==29579== To see them, rerun with: --leak-check=full --show-leak-kinds=all ==29579== ==29579== For lists of detected and suppressed errors, rerun with: -s ==29579== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) . As you can see, the program allocates 11,735 integers, but frees only 5,850 of them. Valgrind tells us that the error is due to the malloc call in the program at line 10: . ==29579== at 0x4845888: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==29579== by 0x11B414: copyAndFreeVector(int) (program.cpp:10) . Let’s solve the problem and run fuzz testing again. . #include &lt;deepstate/DeepState.hpp&gt; #include &lt;Rcpp.h&gt; #include &quot;RcppDeepState.h&quot; using namespace deepstate; // [[Rcpp::export]] void copyAndFreeVector(int source){ // allocates some space for 1 integer int* sample = (int*) malloc(sizeof(int)); free(sample); } TEST(IntAllocation, AllocateIntegerWithoutFree) { int v = RcppDeepState_int(0, 1000); copyAndFreeVector(v); } . With the exception of the 8 bytes classified as stil reachable, we don’t have any memory leaks this time. I discovered that these 8 bytes are related to the inclusion of the R library (-lR argument). . ==29423== Memcheck, a memory error detector ==29423== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al. ==29423== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info ==29423== Command: ./program --fuzz --timeout=1 ==29423== INFO: Starting fuzzing WARNING: No seed provided; using 1653991674 WARNING: No test specified, defaulting to first test defined (IntAllocation_AllocateIntegerWithoutFree) INFO: Done fuzzing! Ran 6335 tests (6335 tests/second) with 0 failed/6335 passed/0 abandoned tests ==29423== ==29423== HEAP SUMMARY: ==29423== in use at exit: 8 bytes in 1 blocks ==29423== total heap usage: 6,359 allocs, 6,358 frees, 144,452 bytes allocated ==29423== ==29423== LEAK SUMMARY: ==29423== definitely lost: 0 bytes in 0 blocks ==29423== indirectly lost: 0 bytes in 0 blocks ==29423== possibly lost: 0 bytes in 0 blocks ==29423== still reachable: 8 bytes in 1 blocks ==29423== suppressed: 0 bytes in 0 blocks ==29423== Reachable blocks (those to which a pointer was found) are not shown. ==29423== To see them, rerun with: --leak-check=full --show-leak-kinds=all ==29423== ==29423== For lists of detected and suppressed errors, rerun with: -s ==29423== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) . Conclusion . In this post we have seen how to use RcppDeepState auxiliary functions to manually generate a Test Harness. This is a procedure that is always done in an automated way by using deepstate_harness_create(). The purpose of this post is to understand how the Test Harness creation procedure works and combine RcppDeepState with a simple Rcpp program. . Rcpp package on CRAN &#8617; . | Akhila Chowdary blog &#8617; . | DeepState symbols definition &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/rcppdeepstate/fuzz/r/2022/05/31/rcppdeepstate-introduction.html",
            "relUrl": "/rcppdeepstate/fuzz/r/2022/05/31/rcppdeepstate-introduction.html",
            "date": " • May 31, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "Advanced fuzz testing with DeepState and Valgrind",
            "content": "Advanced fuzz testing . In the previous posts we have seen how to use DeepState to find simple errors in programs. The problem of the basic fuzz testing approach is that it does not allow us to detect more subtle issues, such as memory faults. In this article we introduce and explain a more advanced fuzz testing approach using the Valgrind memcheck tool and DeepState . Valgrind introduction . Valgrind is a debugging and profiling tool for Linux applications. The Valgrind distribution comes with a set of useful tools: a thread error detector (Helgrind), a cache profiler (Cachegrind), a heap profiler(Massif), a memory problem analyzer (Memcheck), and other tools are included in the Valgrind suite 1. For our purpose and interest we will focus uniquely on the Memcheck tool. This tool allows you to do an advanced memory analysis to identify two types of memory errors: . Memory leaks | Memory errors | . The first is related to missed frees: a software allocates memory in the heap dynamically and then forgets to free it. The latter is caused by more subtle errors, such as reading or writing from uninitialized memory locations: a program writes some bytes in a memory location that has not been initialized. Valgrind has a module called Memcheck that can help you find these kinds of issues. . Usage . With some simple steps we can perform an advanced memory analysis over a compiled binary. Before the analysis can take place, in order to have as much information as possible from the analysis results such as the error line number, it’s convenient to compile the program by passing the -g parameter to the g++ compiler. This option will produce more debugging information that will be included in the resulting binary. . Sample usage . The following is a description of the analysis procedure for a basic C++ program that allocates but does not release memory bytes. The program is reported in the following code snippet. As you can see the malloc invocation isn’t followed by a free, thus what we are expecting from Valgrind is a warning from the Memcheck tool about the missing free. . #include &lt;cstdlib&gt; int main(int argc, char** argv){ // allocates some space for 5 integers int* sample = (int*) malloc(sizeof(int) * 5); return 0; } . As previously noted, the program should be constructed using the -g argument to provide greater information about any mistakes that may occur during the analysis. Another useful option is --leak-check=full which performs a full analysis for memory leak problems at the end of the execution. . g++ -o program -g program.cpp . Now it is possible to run Valgrind by specifying the tool to use with the --tool parameter . valgrind --tool=memcheck ./program . The result for this analysis will look similar to the followng one . ==108488== Memcheck, a memory error detector ==108488== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al. ==108488== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info ==108488== Command: ./program ==108488== ==108488== ==108488== HEAP SUMMARY: ==108488== in use at exit: 20 bytes in 1 blocks ==108488== total heap usage: 2 allocs, 1 frees, 72,724 bytes allocated ==108488== ==108488== 20 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==108488== at 0x4845888: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==108488== by 0x109151: main (program.cpp:5) ==108488== ==108488== LEAK SUMMARY: ==108488== definitely lost: 20 bytes in 1 blocks ==108488== indirectly lost: 0 bytes in 0 blocks ==108488== possibly lost: 0 bytes in 0 blocks ==108488== still reachable: 0 bytes in 0 blocks ==108488== suppressed: 0 bytes in 0 blocks ==108488== ==108488== For lists of detected and suppressed errors, rerun with: -s ==108488== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) . The error summary shows that there is an error, in particular if we look at the leak summary we can see that 20 bytes are lost. So the question seems quite straightforward but, where does these 20 bytes come from? If we read carefully the valgrind description the error is found in the main function of our code at line 5 as stated by the following message . ==108488== by 0x109151: main (program.cpp:5) . The error in fact comes from the call to the malloc function that allocates 5 * sizeof(int) = 5 * 4 bytes = 20 contiguous bytes in heap but doesn’t free them. Note that the size of an integer is compiler and architecture dependent: in my case the size of a single int in memory is 4 bytes. . DeepState and Valgrind . Let’s take a closer look at how Valgrind may be used in conjunction with the fuzzing approaches described in my earlier postings. As previously stated, basic fuzz testing is restricted in its ability to detect just certain types of programming problems. Consider combining the power of Valgrind memory checks with the benefits of fuzz testing. That is precisely what we will explore in this section. . Fuzz testing programs to find memory safety errors using Valgrind and DeepState allows to increase the probability of finding subtle errors. . Use case example . Assume you’re writing a function that accepts a pointer to the beginning of a string, copies it into a new heap-allocated string, and then frees it. Consider that while developing this function, the developer forgot about the size of the source string. A careful reader would have caught the mistake and addressed the problem, however we want to understand how Valgrind with the auxiliary of DeepState could quickly find the problem. As you may have seen, the issue is caused by two factors: . the contiguous memory area pointed by newStr can contain a string of at most 20 characters; | the memcpy function doesn’t check for any terminating null character. | . This means that if someone passes as input parameter a string longer than 20 character, an heap overflow occur 2. . #include &lt;cstdlib&gt; #include &lt;cstring&gt; void copyAndFreeString(char* source){ // allocates some space for 20 characters char* newStr = (char*) malloc(sizeof(char) * 20); memcpy(newStr, source, strlen(source)); free(newStr); } int main(int argc, char** argv){ copyAndFreeString(argv[1]); return 0; } . Test with Valgrind . Now let’s consider to use Valgrind to check for any memory issue in the above program. The developer can try a lot of different options, forgetting about the border case(string greater than 20). . valgrind ./program 12345678 valgrind ./program hello world valgrind ./program test ... . The result for all this test looks similar to the following for the first command execution. . ==9019== Memcheck, a memory error detector ==9019== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al. ==9019== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info ==9019== Command: ./program 12345678 ==9019== ==9019== ==9019== HEAP SUMMARY: ==9019== in use at exit: 0 bytes in 0 blocks ==9019== total heap usage: 2 allocs, 2 frees, 72,724 bytes allocated ==9019== ==9019== All heap blocks were freed -- no leaks are possible ==9019== ==9019== For lists of detected and suppressed errors, rerun with: -s ==9019== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) . As you can see, it seems like everything is working fine, no error, no leak. However the developer missed to execute the border case. What we can learn here is that the greater the number of executions with varied inputs, the greater the chance of discovering subtle errors. . Test with Valgrind and DeepState . Let’s integrate DeepState with the previous code fragment. First of all we remove the main function and we create a TEST function. This is the Test Harness creation phase, discussed in the previous posts3. . #include &lt;cstdlib&gt; #include &lt;cstring&gt; void copyAndFreeString(char* source){ // allocates some space for 20 characters char* newStr = (char*) malloc(sizeof(char) * 20); memcpy(newStr, source, strlen(source)); free(newStr); } TEST(StringCopy, CopyAndFreeString) { char* str = DeepState_CStrUpToLen(30, &quot;abcdefABCDEF&quot;); ASSUME_GT(strlen(str), 1); copyAndFreeString(str); } . As you can see the same standard structure is used to define a test function with the TEST macro: we start by providing some symbolic variables, then the pre conditions and finally the post conditions. The post conditions aren’t useful in this situation because we’re simply looking for memory related issues. . The compilation process can be started with the following command after specifying the compiler to include the headers for DeepState and to include debugging information in the final binary . g++ -ldeepstate -o program -g program.cpp . This time instead of running Valgrind and DeepState separated we can run them together to achieve the maximum performance . valgrind --tool=memcheck ./program --fuzz --timeout=1 . ==16724== Memcheck, a memory error detector ==16724== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al. ==16724== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info ==16724== Command: ./program --fuzz --timeout=1 ==16724== INFO: Starting fuzzing WARNING: No seed provided; using 1653599264 WARNING: No test specified, defaulting to first test defined (StringCopy_CopyAndFreeString) ==16724== Invalid write of size 8 ==16724== at 0x484FA11: memmove (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==16724== by 0x114D25: copyAndFreeString(char*) (program.cpp:11) ==16724== by 0x114E6B: DeepState_Test_StringCopy_CopyAndFreeString() (program.cpp:26) ==16724== by 0x114D3D: DeepState_Run_StringCopy_CopyAndFreeString() (program.cpp:23) ==16724== by 0x10FD10: DeepState_RunTestNoFork (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== by 0x110234: DeepState_FuzzOneTestCase (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== by 0x1104C7: DeepState_Fuzz (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== by 0x10B98A: main (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== Address 0x4df6cf0 is 16 bytes inside a block of size 20 alloc&#39;d ==16724== at 0x4845888: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==16724== by 0x114CFF: copyAndFreeString(char*) (program.cpp:9) ==16724== by 0x114E6B: DeepState_Test_StringCopy_CopyAndFreeString() (program.cpp:26) ==16724== by 0x114D3D: DeepState_Run_StringCopy_CopyAndFreeString() (program.cpp:23) ==16724== by 0x10FD10: DeepState_RunTestNoFork (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== by 0x110234: DeepState_FuzzOneTestCase (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== by 0x1104C7: DeepState_Fuzz (in /home/fabri/test/testHarness/TestHarnessSample/program) ==16724== by 0x10B98A: main (in /home/fabri/test/testHarness/TestHarnessSample/program) ... truncated file ... INFO: Done fuzzing! Ran 1 tests (1 tests/second) with 0 failed/1 passed/0 abandoned tests ==16724== ==16724== HEAP SUMMARY: ==16724== in use at exit: 0 bytes in 0 blocks ==16724== total heap usage: 3 allocs, 3 frees, 72,754 bytes allocated ==16724== ==16724== All heap blocks were freed -- no leaks are possible ==16724== ==16724== For lists of detected and suppressed errors, rerun with: -s ==16724== ERROR SUMMARY: 6 errors from 3 contexts (suppressed: 0 from 0) . This time the results are quite different: Valgrind with the auxiliary of DeepState was able to discover 6 errors from 3 different contexts. As we can see from the analysis of Valgrind (I have truncated the analysis to only the first error) the error is caused by the memmove invocated by memcpy in the program ad line 11. . Conclusion . Using only one tool is not always the best approach to find subtle programming errors. In fact in this article we discussed a advanced technique to perform a more sophisticated analysis. By combining fuzz testing from DeepState with memory analysis from Valgrind we were able to address more errors than the one we could have discovered by using a single technique. . Valgrind tools &#8617; . | Heap overflow &#8617; . | Test Harness creation guide &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/deepstate/fuzz/c++/valgrind/2022/05/27/advanced-deepstate.html",
            "relUrl": "/deepstate/fuzz/c++/valgrind/2022/05/27/advanced-deepstate.html",
            "date": " • May 27, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "DeepState introduction",
            "content": "DeepState Introduction . DeepState is a framework which provides developers the possibility to perform symbolic unit testing on some particular C++ functions by writing test harnesses. For writing a test harness, Deepstate follows a similar approch to the one of Google tests 1. The common problem between most of the symbolic unit testing libraries is that you as developer have to know how to use other binary analysis tools. With Deepstate this problem is solved by provinding a common interface the test harness creation process. . Installation . The installation process is quite simple, you just need to follow the istruction provided in the Readme file in the Deepstate repository on GitHub 2. In my case after the installation of all the necessary dependencies, I downloaded the repository snapshot using the standard git clone approach . git clone https://github.com/trailofbits/deepstate.git . and then started the compilation process with the auxiliary of Make tools . mkdir deepstate/build &amp;&amp; cd deepstate/build cmake ../ make . If the compilation process succeed the next step is the installation of the compiled files in the proper location in the host system: . sudo make install . Test Harness creation . Testing C++ code is not a straightforward task and it need to be accomplished in the correct way, otherwise it will lead to a failure both in the test and also in the source code. A Test Harness is a collection of software that allows to test a particular program by executing under some conditions. . The first step in test harness creation is to include the library and optionally set the namespace, in order to use all the functionalities provided by DeepState : . #include &lt;deepstate/DeepState.hpp&gt; using namespace deepstate; . A Test Harness definition in DeepState starts with the TEST macro. This macro takes two arguments as input: . a unit name | a test name | . The body of the function that starts with TEST will contain the following parts: . symbols definition | pre-conditions | post-conditions | . Let’s dive into this three main parts of a Test Harness creation procedure. . Symbols definition . The first part consists in the definition of the symbols that will be used as input for the function we need to test. The main goal for this task is to have a set of variables that will be filled by the DeepState with some non-deterministic data. . Symbolic execution tools and fuzzers needs to know which variable is symbolic in order to control them. Symbols definitions for basic data types (int, char, ..) are defined by concatenating the data type name with the symbolic_ prefix (symbolic_int, symbolic_char, ..). . DeepState provides us some useful functions to initialize our symbols with random data: . int DeepState_IntInRange(int low, int high) : initializes the symbol with an integer in the range low-high | float DeepState_FloatInRange(float low, float high) : initializes the symbol with a float number in the range low-high | double DeepState_DoubleInRange(double low, double high) : initializes the symbol with a double number in the range low-high | char* DeepState_CStr_C(size_t len, const char* allowed) : initializes a character array (a string) of length len with a set of allowed character taken from the character array `allowed | char* DeepState_CStrUpToLen(size_t maxLen, const char* allowed) : initializes a character array (a string) of length up to len with a set of allowed character taken from the character array allowed | . Pre conditions . Sometimes there is the necessity to constraint a little bit more the symbolic variables defined previously. This means that you have some particular constraint that your symbolic variable need to comply with, before running into the tests. All the tests that do not pass the pre conditions will be considered abandoned. . Pre conditions are defined using the ASSUME macro and also by the following more specialized ones: . ASSUME_EQ : checks for the equality of the 2 parameters (operator ==) | ASSUME_NE : checks if the 2 parameters are not equal (operator !=) | ASSUME_LT : checks if the first parameter is less than the second (operator &lt;) | ASSUME_LE : checks if the first parameter is less or equal to the second (operator &lt;=) | ASSUME_GT : checks if the first parameter is greater than the second (operator &gt;) | ASSUME_GE : checks if the first parameter is greater or equal to the second (operator &gt;=) | . Example . Suppose you have to pass to your test only strings with a minimum length of 5 characters and up to 10 characters (both inclusive). This types of strings can not be created by only using DeepState_CStrUpToLen. We have to constraint the fact that the length of the string should also be greater then 5. This may be accomplished by using a precondition that checks if the created string meets the requirement that its length be larger than or equal to 5. With the preceding list in mind, this can be implemented with the ASSUME_GE macro in the following way: . TEST(UnitName, TestName) { char* str = DeepState_CStrUpToLen(50, &quot;abcdefABCDEF&quot;); ASSUME_GE(strlen(str), 5); ... } . Post conditions . The last part is the check of the execution result of a test. This can be done with post conditions that checks if the results satisfy some constraints. Similar to the pre conditions, the post condition defines a list of macros that help us to perform this checks. This time a post condition is defined using the ASSERT macro and all it’s specialized versions (ASSERT_EQ, ASSERT_NE, ASSERT_FALSE, …). . Example . Assume that we want to test a function that compress a string as input into a fixed length string : an hash function like MD5. A possible post condition will check if the hashed string is of a certain length (in the case of md5, exactly 32 characters). . TEST(UnitName, TestName) { char* str = DeepState_CStrUpToLen(50, &quot;abcdefABCDEF&quot;); // Pre conditions ASSUME_GE(strlen(str), 5); // execution char* hashedString = md5(str); // post conditions ASSERT_EQ(strlen(hashedString), 32); } . Test harness compilation . You can compile the test harness using a standard C++ compiler like g++ by specifying the linker to include the deepstate header with the -ldeepstate parameter . g++ -ldeepstate -o harness harness.cpp . The output of this procedure is a compiled harness file that can be executed. . Fuzz test execution . The compiled test harness can be executed using some analysis tools like manticore, angr or valgrind to discover memory leaks in the code. You can also run it in a standalone mode by executing it directly in the console with the --fuzz option. This last option enables DeepState to perform brute force fuzzing. Another useful option is --timeout that allows to specify a timeout(in seconds) after which the fuzzing procedure will be stopped. In addition with the --input_which_test you can specify the test to execute in the format UnitName_TestName. . ./harness --fuzz --timeout=5 --input_which_test UnitName_TestName . This execution will give us the total number of failed, passed and abandoned tests . Advanced fuzz testing . I’ll go through how to use DeepState in conjunction with more complex tools like Valgrind in the next blog posts. . https://google.github.io/googletest/ &#8617; . | https://github.com/trailofbits/deepstate#buildnrun &#8617; . |",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/deepstate/fuzz/c++/2022/05/25/about-deepstate.html",
            "relUrl": "/deepstate/fuzz/c++/2022/05/25/about-deepstate.html",
            "date": " • May 25, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "Sample DeepState fuzz test",
            "content": "Sample usage of the Deepstate C++ library . Assume that the NASA FPrime library contains a function that converts a string to a Mixed-Uppercase string. In reality the NASA FPrime contains a lot of functions that deals with strings. What is a Mixed-Uppercase string? With this term I am referring to a string which all characters in odd positions must be capitalized. The following is a very simple function that computes this task: . char* mixedUppercase(char* source){ for( int i=0; i&lt; strlen(source); i+=2 ){ // check if the character at the ith position is lowercase, otherwise skip if (*(source + i) &gt;= 97 &amp;&amp; *(source + i) &lt;= 122){ *(source + i) -= 32; } } return source; } . This function takes a character array as input and performs the odd-uppercase replacement in place. This function returns the pointer to the first character of the original char vector. . Test harness creation . First of all I’ll start writing the TestHarness after I’ve determined what the expectations are for this function. First, I’ll include the DeepState library’s required header files: . #include &lt;deepstate/DeepState.hpp&gt; . Then, using the TEST macro, I’ll begin constructing the test function, taking into account the expected outcome from the mixedUppercase function. The following code sample illustrates one possible implementation: . TEST(MixedUppercase, OnlyGeneratedMixedUppercase) { char* str = DeepState_CStrUpToLen(50, &quot;abcdefABCDEF&quot;); ASSUME_GT(strlen(str), 1); mixedUppercase(str); ASSERT_TRUE(isMixedUppercase(str)) &lt;&lt; str &lt;&lt; &quot; is not a mixed uppercase string&quot;; } . This test function creates a string with a length of up to 50 characters, containing characters from the set &quot;abcdefABCDEF&quot;. After that we make the assumption that the the strings that are relevant for the test are the one of a length greter than 1. Finally we execute our function and we check using the ASSERT_TRUE postcondition that the result is a Mixed-Uppercase string. . Where the isMixedUppercase function returns True if the string passed is a Mixed-Uppercase string, otherwise false. . bool isMixedUppercase(char* str){ bool res = true; for (int i=0; i&lt; strlen(str); i+=2){ res = res &amp;&amp; (*(str + i) &gt;= 65 &amp;&amp; *(str + i) &lt;= 90); } return res; } . Fuzz testing . Now that the Test harness is written, I can move on and perform some fuzz testing over the function. First I will compile the Test harness by specifying the linker to include the deepstate header with the -ldeepstate parameter . g++ -ldeepstate -o harness harness.cpp . Finally I run a non deterministic fuzz testing on the TestHarness by executing the compiled TestHarness with the following parameters . ./harness --fuzz --timeout=1 --input_which_test MixedUppercase_OnlyGeneratedMixedUppercase . Result . After the execution I can check the results. As expected, in my case no error was found. . INFO: Starting fuzzing WARNING: No seed provided; using 1652815282 INFO: Done fuzzing! Ran 18918 tests (18918 tests/second) with 0 failed/17447 passed/1471 abandoned tests .",
            "url": "https://fabriziosandri.github.io/gsoc-2022-blog/deepstate/fuzz/c++/2022/05/17/deepstate-sample.html",
            "relUrl": "/deepstate/fuzz/c++/2022/05/17/deepstate-sample.html",
            "date": " • May 17, 2022"
        }
        
    
  

  
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://fabriziosandri.github.io/gsoc-2022-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}